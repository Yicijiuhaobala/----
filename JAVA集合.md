# Collection接口：存放单一元素
## List: 存储的元素是有序的，可以重复的

### ArrayList Object[]数组 继承AbstractList
- 底层使用Object[]数组进行存储，适用于频繁的查找工作，线程不安全
- 底层使用的数组，因此插入和删除元素的时间复杂度受元素位置的影响，
- 实现了RandomAccess接口，表明实现该接口的List实现类时支持快速随机访问的，通过元素序号快速获取元素。支持快速随机访问，存储元素花费的空间比LinkedList更小，但是它仍然会预留一定的容量空间
- 实现了Cloneable接口，表示能被克隆，实现了Serializable表示支持序列化，能通过序列化去传输
  - 扩容机制
  - ArrayList的初始化方式有三种，一种是默认构造函数，使用初始容量为10构造一个空列表(无参数构造)，此时初始化赋值的是一个空列表，当真正对数组进行添加元素时才真正分配容量，添加第一个元素时，数组容量扩充为10，一种是指定初始容量的构造方法，第三种是构造包含指定Collection元素的列表，元素利用该集合的迭代器进行返回
  - jdk1.11当添加元素时，首先会进行操作次数的增加，同时会判断数组的长度与数组真正存储的数据个数，如果数组不足以存放该数据会进行扩容 grow()函数，扩容时会进行数组的的复制同时会经过newCapacity函数，确定新的容量。
  - ArrayList每次扩容之后容量都会变成原来的1.5倍，源代码中写的是右移。当添加第一个元素是，会经过第一个if判断，比较minCpacity与默认设置的10的大小，进行扩容。当之后进行扩容时，不再进入第一个if判断语句，直接进行语句的返回。如果newCapacity小于数组最大值，直接返回newCapacity，数组容量扩充为1.5倍，数组的个数size+1
  - length属性是针对数组所说的，length()方法是针对字符串说的，size()是针对泛型集合说的
  - hugeCapacity()函数是判断minCapacity与数组size最大值，如果minCapacity更大，大于最大容量，则为Integer.MAX_VALUE 反之为Integer.MAX_VALUE-8
### LinkedList 双向链表
- LinkedList1.6之前使用的是循环链表，之后取消了循环链表，改用双向链表，它也是线程不安全的
- 底层使用的是循环链表，插入或者删除元素的时间复杂度都是O(1)
- LinkedList存储元素时还得存储直接前驱和直接后继以及数据
- 仅在头尾插入或者删除元素时时间复杂度为O(1),其他时候也是为O(n)

### Comparable和Comparator
- Comparable接口是出自java.lang包，他有一个compareTo(Object obj)方法 ，**实现接口重写方法**
- Comparator接口是出自java.utils包，他有一个compare(Object obj1, Object obj2)方法，**使用匿名内部类实现自定义排序**
- 两者都用来进行自定义排序
### 无序性和不可重复性的含义
- 无序性不等于随机性，无序性试着存储的数据在底层数组中**并非按照数组索引的顺序添加，而是根据的哈希值决定的**
- 不可重复性: 指添加的元素按照equals()进行判断，需要同时重写equals()和hashCode()方法
### Vector Object[]数组
- 底层使用Object[]数组进行存储，线程安全

## Set：存储的元素是无序的，不可以重复的 以下三种实现类都不是线程安全的，保证元素唯一

### HashSet：无序，唯一，底层是哈希表(基于HashMap)，利用HashMap保存元素
- 用于不需要保证元素插入和取出顺序的场景
- 当把对象加入HashSet时，会先计算对象的Hashcode值来判断对象加入的位置，同时也会和其他对象的hashcode值做比较，如果没有相符的hashcode，就假设该对象没有重复出现。但是如果出现相同hashcode值得对象时，会调用equals()方法来检查两个对象是否真的相同，如果两者相同就不会成功加入
- 实际上无论HashSet中是否存在某元素，HashSet都会直接插入，知识会在add()方法得返回值处告知我们插入前是否存在相同的元素。
### LinkedHashSet: HashSet的子类，底层是LinkedHashMap,链表和哈希表，元素的插入和取出满足FIFO
- 用于需要保证元素插入和取出顺序满足FIFO的场景

### TreeSet:有序，唯一，红黑树（自平衡的排序二叉树）排序的方式有自然排序和定制排序
- 用于支持对元素自定义排序规则的场景

## Queue: 存储的元素是有序的，可以重复的，按特定的排队顺序来确定先后顺序，例如队列和栈
- Queue是单端队列，只能从一端插入元素，另一端删除元素，遵循FIFO的规则
- 根据容量问题而导致操作失败后处理方式的不同可以分为两大类: 一种在操作失败后会抛出异常，另一种则会返回特殊值
- 
### Deque: 双端链表
- Deque是双端列表，在其两端都可以插入或者删除元素 它扩展了Queue的接口，增加了在队尾和队首进行插入和删除的方法。也分为返回特殊值和抛出异常。
- Deque也提供了push()和pop()方法，用于模拟栈
- 
### PriorityQueue : Object[]数组实现二叉堆  
- **被广泛应用于堆排序 求第K大的数，带权图的遍历**
- 与Queue的区别是，元素出对顺序是与优先级相关的，即**总是优先级最高的元素先出队**。
- 利用了二叉堆的数据结构来实现，底层使用可变长的数据来存储数据
- 通过堆元素的上浮和下沉，实现了O(logn)时间复杂度内插入元素和删除堆顶元素
- 非线程安全的，不支持NULL 和 non-comparable对象
- 默认是小顶堆，但是可以接受Comparator作为构造参数，来自定义元素优先级的先后

### ArrayQueue: Object[]数组 + 双指针
- 基于**可变长的数组和双指针实现**， LinkedList由双向链表实现
- 不支持存储NULL数据， LinkedList支持
- 插入时可能存在扩容过程，但是均摊后的插入操作依然为O(1),LinkedList不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢

### BlockingQueue 
- 阻塞队列，继承自Queue 其支持当队列没有元素时一直阻塞，指导有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。
- **常用于生产者-消费者模型中**，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据
- 实现类
  -  ArrayBlockingQueue
    -  底层采用数组来实现，它一旦被创建，容量就不能改变了，它是**有界队列**，并发控制采用可重入锁ReentrantLock，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。 **默认情况下不能保证线程访问队列的公平性**，**它的锁是不分离的，生产和消费共用同一个锁**
    - 公平性：严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到ArrayBlockingQueue
    - 非公平性：访问ArrayBlockingQueue并不是按照线程等待的绝对时间顺序。 如果保证绝对性，需要降低吞吐量。
  - LinkedBlockingQueue
    - 底层基于单向链表实现的阻塞队列，可以做无界队列也可以做有界队列，满足FIFO的特性  通常在创建的时候会指定它的大小，没有指定的情况下容量等于Interger.MAX_VALUE，**锁是分离的，生产者和消费者之间使用的是不同的锁，避免了线程之间的争夺**
  - PriorityBlockingQueue 
    - 一个支持优先级的无界阻塞队列 默认情况下采用自然顺序进行排序  也可以自定义类实现compareTo()方法来指定元素排序规则 初始化时通过构造器参数Comparator来指定排序规则
    - 不可以插入null值，插入队列的对象必须是可比较大小的。
    - 当后面插入元素的时候如果空间不够的话会自动扩容
  - DelayQueue
    - 延迟队列 其中的元素只有到了其指定的延迟时间，才能从队列中出队
  - SynchronousQueue
    - 同步队列 一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，每个删除操作都必须等待插入操作。**常用于线程之间进行数据传输**


# Map接口：存放key-value键值对 key是无序的，不可以重复的，value是无序的，可以重复的。
## HashMap 数组+链表，主体是数组，链表是为了解决哈希冲突而存在（拉链法解决冲突）。jdk1.8之后，当链表的长度大于阈值（默认为8），（将链表转换为红黑树之前会判断，如果当前的数组长度小于64，那么还会先进行数组扩容，而不是转换为红黑树），当转换为红黑树时，会减少搜索时间
- HashMap是非线程安全的，HashTable是线程安全的，HashTable内部的方法基本都经过synchronized修饰，如果想保证线程安全，就使用ConcurrentHashMap
- 因为线程安全的问题，HashMap比HashTable高效，同时HashTable基本要被淘汰了
- HashMap可以存储null的key和value，但是null作为键只能有一个，null作为值可以有多个，但是HashTable不允许有null键和null值，否则会抛出异常
- Hashtable的默认初始大小为11，每次扩容变为原来的2*n+1,**HashMap的默认初始化大小为16，每次扩容，会将其扩充为原来的2倍**。当给定了容量初始值，Hashtable会直接使用给定的大小，但是**HashMap总是使用2的幂次方大小**，源码中tableSizeFor()来实现大小为2的幂次方大小
- jdk1.8之后，HashMap会有进化为红黑树的机制，但是Hashtable并没有
- HashMap是使用键来计算Hashcode，HashSet是使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以需要利用equals()方法来判断对象的相等性 ，同时HashSet的底层就是HashMap实现的、
- 底层实现
  - jdk1.8之前底层时数组和链表结合在一起使用也就是链表散列。HashMap通过key的hashcode经过扰动函数处理过后得到Hash值，然后通过(n-1)&hash判断当前元素的存放的位置(n指的时数组的长度)，如果当前位置存在元素的话，就判断该元素与要存入的元素的hash值以及key是否相同，相同的话直接覆盖，不相同采用拉链法解决冲突。所谓的扰动函数就是HashMap的hash()方法，该方法为了防止一些实现比较差的hashCode()方法，减少碰撞。
  - 拉链法就是将链表和数组相结合，创建一个链表数组，数组中的每一格都是一个链表，若遇到哈希冲突就将冲突的值加到链表中即可。
  - jdk1.8之后，解决哈希冲突有了较大的变化，当链表长度大于阈值(默认为8)(将链表转换成红黑树前会判断，如果数组的长度小于64，就会选择继续进行数组扩容，而不是转换为红黑树)，将链表转换为红黑树，减少搜索时间。红黑树就是解决二叉查找树的缺陷，二叉查找树在一些情况下会退化成为一个线性结构。
  - **HashMap的长度为什么是2的幂次方？**为了能让HashMap存储高效，尽量减少碰撞，尽量把数据分配均匀。hash的值范围是很大的，但是这么长的数组，内存是放不下的，不能直接拿来用，用之前还需要对数组的长度进行取模运算，得到的余数才能用来要存放的位置也就是数组下标，而这个数组下标的计算方法是(n-1)&hash。当length为2的n次方时，hash%length==hash&(length-1)，采用二进制位操作，相对于取余操作提高了运算效率，这就解释了为什么HashMap的长度是2的幂次方
  - **HashMap多线程操作会导致死循环操作**，并发下的Rehash会造成元素之间形成一个循环链表，多线程下推荐使用ConcurrentHashMap
    - 当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。 虽然尾插法能解决头插法带来的这个问题，但**推荐使用ConcurrentHashMap**
  - **HashMap的七种遍历方式**：
    - 
- loadFactor 加载因子 控制数组存放数据的疏密程度。越趋近于1，数组中存放的数据就越多越密集，越趋近于0，数组存放的数据就越分散，稀疏。当loadFactor过大时，查找效率会降低，过小时，数组利用率就不够高。默认是0.75f 给定的默认容量是16 ，16*0.75=12 threshold， 数量超过12时，就需要进行扩容。
- 一共有四个构造方法 默认构造方法 指定容量的构造方法，指定容量和加载因子的构造方法，指定Map的构造方法

## ConcurrentHashMap(源码重点 还需要继续观看)
- jdk1.7其底层采用的时分段的数组+链表实现，jdk1.8采用的数据结构跟HashMap的数据结构一样，都是数组+链表/红黑树
- jdk1.8之前，将数据分为一段一段的进行存储，这个段就是segment，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个数据段时，其他段的数据也能被其他线程访问，由segment和hashEntry，用于存储键值对数据。segment个数一旦被初始化就不能改变，大小默认时16，也就是说默认可以同时支持16个线程并发写。对同一个segment的并发写入会被阻塞，不同segment的写入是可以并发执行的。segment的结构类似一个HashMap结构，
- jdk1.8之后，完成进行重写，采用Node+CAS+synchronized保证并发安全，数据结构跟HashMap1.8的结构类似，也存在进化成红黑树的情况。锁粒度更细，synchronized只锁定当前链表或者红黑树二叉树的首节点，只要hash不冲突，就不会产生并发问题，不会影响其他Node的读写，效率大幅提升
- 线程安全实现方式: jdk1.7采用segment分段锁来保证安全，segment继承自ReentrantLock，jdk1.8放弃了segment分段锁的设计，采用Node+CAS+synchronized保证线程安全，锁粒度更细
- hash碰撞解决方法: jdk1.7采用拉链法，jdk1.8采用拉链法结合红黑树
- 并发度:jdk1.7的最大并发度时segment的个数，默认是16，jdk1.8最大并发度是Node数组的大小，并发度更大
## LinkedHashMap

## HashTable 数组+链表，数组是HashTable的主体，链表是为了解决哈希冲突而存在
- 使用synchronized来保证线程安全，效率低下。当一个线程访问同步方法时，其他线程也访问同步方法时，可能会进入阻塞或者轮询状态，如使用put方法时，另一个线程不能使用put方法，竞争激烈

## TreeMap 红黑树（自平衡的排序二叉树）
- TreeMap拥有对集合内元素的搜索的能力，同时它也有对集合中的元素根据键排序的能力，默认是按照key的升序排序，不过我们也可以自定义进行排序
- **TreeMap相比HashMap主要多了对集合中的元素根据键排序的能力以及对集合中元素搜索的能力**





## ArrayList
- 共有三种方式进行初始化
  - 默认构造函数 使用初始容量为10构造一个空列表， **实际上初始化赋值的是一个空数组，当真正对数组进行元素操作时才会真正分配容量**。当向数组中添加第一个元素时，数组容量扩为10
  - 带初始容量的构造函数
  - 构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序进行返回
- 在arraylist的扩容中，使用位运算进行计算，位运算的速度远远快于整除运算，每次扩容之后容量都会变为原来的1.5倍，采用的右移一位运算。

## LinkedList
- LinkedList 底层结构时链表，内存地址是不连续的，只能通过指针进行定位，不支持随机快速访问，不能实现RandomAccess接口
- 两种初始化方式
  - 无参构造函数 创建一个空的链表对象
  - 接受一个集合类型作为参数，创建一个与传入集合相同元素的链表对象
- 添加元素 ，有直接在链表尾添加元素，也可以指定位置添加元素
- 获取元素，指定index获取元素时，通过比较索引值与链表size的一半大小来确定从链表投还是尾开始遍历。如果索引值小于size的一般，就从链表头开始遍历，反之从链表尾开始遍历。

## HashMap
- jdk1.8之前
  - 底层是数组+链表 
  - 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。
  - 所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。 jdk1.8的hash方法相比jdk1.7更加简化，jdk1.7扰动了4次
- jdk1.8之后
  - 当链表长度大于阈值（默认为 8）时，会首先调用 treeifyBin()方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 resize() 方法对数组扩容。
  - loadFactor负载因子 控制数组存放数据的疏密程度
  - threshold capacity*loadFactor的乘积，size大于该值时，需要对数组进行扩增
  - 四种构造函数
    - 默认构造函数
    - 包含另一个map的构造函数
    - 指定“容量大小”的构造函数
    - 指定“容量大小”和“负载因子”的构造函数
  - 添加元素 进行相应的操作

## ConcurrentHashMap
- jdk1.7中 
  - ConcurrnetHashMap 由很多个 Segment 组合，而每一个 Segment 是一个类似于 HashMap 的结构，所以每一个 HashMap 的内部可以进行扩容。但是 Segment 的个数一旦初始化就不能改变，默认 Segment 的个数是 16 个，你也可以认为 ConcurrentHashMap 默认支持最多 16 个线程并发。
- jdk1.8中
  - 相对于 Java7 来说变化比较大，不再是之前的 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 / 红黑树。当冲突链表达到一定长度时，链表会转换成红黑树。

## CopyOnWriteArrayList
- 采用写时复制策略
  - 核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。
- 当需要修改（ add，set、remove 等操作） CopyOnWriteArrayList 的内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值回去，这样就可以保证写操作不会影响读操作了。
- 缺点
  - 内存占用：每次写操作都需要复制一份原始数据，会占用额外的内存空间，在数据量比较大的情况下，可能会导致内存资源不足。
  - 写操作开销：每一次写操作都需要复制一份原始数据，然后再进行修改和替换，所以写操作的开销相对较大，在写入比较频繁的场景下，性能可能会受到影响。
  - 数据一致性问题：修改操作不会立即反映到最终结果中，还需要等待复制完成，这可能会导致一定的数据一致性问题。
- 添加元素
  - add方法内部用到了 ReentrantLock 加锁，保证了同步，避免了多线程写的时候会复制出多个副本出来。锁被修饰保证了锁的内存地址肯定不会被修改，并且，释放锁的逻辑放在 finally 中，可以保证锁能被释放。
  - CopyOnWriteArrayList 通过复制底层数组的方式实现写操作，即先创建一个新的数组来容纳新添加的元素，然后在新数组中进行写操作，最后将新数组赋值给底层数组的引用，替换掉旧的数组。这也就证明了我们前面说的：CopyOnWriteArrayList 线程安全的核心在于其采用了 写时复制（Copy-On-Write） 的策略
  - 每次写操作都需要通过 Arrays.copyOf 复制底层数组，时间复杂度是 O(n) 的，且会占用额外的内存空间。因此，CopyOnWriteArrayList 适用于读多写少的场景，在写操作不频繁且内存资源充足的情况下，可以提升系统的性能表现。
  - CopyOnWriteArrayList 中并没有类似于 ArrayList 的 grow() 方法扩容的操作。
- 获取元素
  - get()方法是弱一致性，在某些情况下可能读到旧的元素值
  - get(int index)方法是分两步进行的：通过getArray()获取当前数组的引用；直接从数组中获取下标为 index 的元素。这个过程并没有加锁，所以在并发环境下可能出现如下情况：
    - 线程 1 调用get(int index)方法获取值，内部通过getArray()方法获取到了 array 属性值；
    - 线程 2 调用CopyOnWriteArrayList的add、set、remove 等修改方法时，内部通过setArray方法修改了array属性的值；
    - 线程 1 还是从旧的 array 数组中取值。

## ArrayBlockingQueue
- BlockingQueue 接口的有界队列实现类，常用于多线程之间的数据共享，底层采用数组实现，从其名字就能看出来了。
- ArrayBlockingQueue 的容量有限，一旦创建，容量不能改变。为了保证线程安全，ArrayBlockingQueue 的并发控制采用可重入锁 ReentrantLock ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。并且，它还支持公平和非公平两种方式的锁访问机制，默认是非公平锁。
- ArrayBlockingQueue 虽名为阻塞队列，但也支持非阻塞获取和新增元素（例如 poll() 和 offer(E e) 方法），只是队列满时添加元素会抛出异常，队列为空时获取的元素为 null，一般不会使用。
- 实现原理
  - ArrayBlockingQueue 内部维护一个定长的数组用于存储元素。
  - 通过使用 ReentrantLock 锁对象对读写操作进行同步，即通过锁机制来实现线程安全。通过 Condition 实现线程间的等待和唤醒操作。
  - 线程间的等待和唤醒具体的实现（不需要记具体的方法，面试中回答要点即可）：
    - 当队列已满时，生产者线程会调用 notFull.await() 方法让生产者进行等待，等待队列非满时插入（非满条件）。
    - 当队列为空时，消费者线程会调用 notEmpty.await()方法让消费者进行等待，等待队列非空时消费（非空条件）。
    - 当有新的元素被添加时，生产者线程会调用 notEmpty.signal()方法唤醒正在等待消费的消费者线程。
    - 当队列中有元素被取出时，消费者线程会调用 notFull.signal()方法唤醒正在等待插入元素的生产者线程。


## 随机访问流


## I/O模型
- 为了保证操作系统的稳定性和安全性，一个进行的地址空间划分为用户空间和内核空间，平常的程序运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，文件管理，进程通信，内存管理等等。用户进程想要执行I/O操作必须通过系统调用来间接访问内核空间。例如磁盘IO(读取文件)和网络IO(网络请求和响应)，我们的应用程序只是发起了IO操作的调用操作而已，具体的IO操作是由操作系统的内核来完成的。
- 应用程序发起I0操作调用后经历的两个步骤:
  - 内核等待IO设备准备好数据
  - 内核将数据从内核空间拷贝到用户空间
- UNIX系统下常见的IO模型: 同步阻塞I/O 同步非阻塞I/O  I/O多路复用 信号驱动I/O和异步I/O
- Java中的3种常见IO模型
  - BIO是同步阻塞IO模型。当应用程序发起read调用后，会一直阻塞，知道内核把数据拷贝到用户空间
  - 同步非阻塞模型中，应用程序会一直发起read调用，但是等待数据从内核空间拷贝到用户空间的这段时间里，线程依旧是阻塞的，直到内核把数据拷贝到用户空间里。该模型的缺点是应用程序不断进行I/O系统调用轮询数据是否已经准备好的过程是十分耗费CPU资源的。
  - IO多路复用模型中，线程手法发起select调用，询问内核数据是否准备就绪，等内核把数据都准备好了，用户线程再发起read调用，read调用的过程(数据从内核拷贝到用户空间)依旧是阻塞的，减少了系统的无效调用，减少了对CPU资源的消耗。
  - NIO中有一个非常重要的Selector选择器，被称为多路复用器。只需要一个线程便可以管理多个客户端连接，只有当客户端数据到了之后才会进行服务。
  - AIO是NIO的改进版，是异步IO模型。异步IO是基于时间和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞，当后台完成处理之后，操作系统会通知相应的线程进行后续的操作。
  - 三者的区别：
    - BIO是用户线程发起请求之后，会进行阻塞等待直到处理完成，进行返回
    - NIO是通过选择器监听多个通道，非阻塞，处理完之后会进行返回
    - AIO是发起请求之后，直接进行返回，等后台处理完成之后才会进行通知回调

## java基础
### 静态方法
- 静态方法为什么不能调用非静态成员？
  - 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问
  - 在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作
- 重载和重写
  - 重载发生在编译器，就是同一个方法能够根据输入数据的不同，做出不同的处理。发生在同一个类中或者父类和子类之间，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同
  - 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写
    - 方法名、参数列表必须一样，子类返回值类型应该比父类更小或者相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类
    - 构造方法无法被重写
    - 父类方法访问修饰符为private final static 子类不能重写该方法
- 接口和抽象类有什么共同点和区别？
  - 共同点
    - 都不能被实例化
    - 都可以包含抽象方法
    - 都可以有默认实现方法
  - 区别
    - 接口主要用于对类的行为进行约束，实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系
    - 一个类只能继承一个类，但可以实现多个接口
    - 接口中的成员变量只能是public static final类型的，不能被修改且必须有初始值，抽象类的成员变量默认default 在子类中可以被重新定义，也可以被重新赋值
- 浅拷贝 深拷贝 引用拷贝
  - 引用拷贝：两个不同的引用指向同一个对象
  - 浅拷贝：浅拷贝会在堆上创建一个新的对象，如果原对象内部的属性是引用类型的化，浅拷贝会直接赋值内部对象的引用地址，拷贝对象和原对象共用同一个内部对象
  - 深拷贝：完全复制震哥哥对象，包括这个对象所包含的内部对象
- String为什么是不可变的？
  - 被final修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能被改变，修饰的变量是引用类型则不能再指向其他对象。String类中使用final修饰的字符数组用来保存字符串是可变的，它属于修饰的变量是引用类型
  - 保存字符串的数组被final修饰且为私有，并且String类没有提供/暴露修改这个字符串的方法
  - String类被final修饰导致其不能被继承。进而避免了子类破坏String的不可变性
- 字符串常量池是JVM为了提升性能和减少内存消耗针对字符串(String类)专门开辟的一块区域，主要目的是为了避免字符串的重复创建
- String.intern()是一个native方法，其作用就是将指定的字符串对象的引用保存再字符串常量池中
  - 如果字符串常量池中保存了对应的字符串的引用，直接返回该引用
  - 如果字符串常量池没有保存对应字符串的引用，就在常量池中创建一个指向该字符串对象的引用并返回
- 对于编译器可以确定值得字符串，也就是常量字符串，JVM会将其存入字符串常量池，并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存入字符串常量池，得益于编译器的优化 **常量折叠**！
  - 引用的值在程序编译期是无法确定的，编译器无法对其进行优化

## java值传递
- 值传递： 方法接收的是实参值的拷贝，会创建副本
  - 参数是基本数据类型的化，传递的就是基本类型的字面量的拷贝，会创建副本
  - 参数是引用类型，**传递的就是实参所引用的对象在堆中地址值的拷贝**，同时也会创建副本
- 引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参

## java序列化
- 序列化： 将数据结构或对象转换成二进制字节流的过程
- 反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程
- **序列化协议应用于TCP/IP协议的应用层 OSI七层模型的表示层**
- 对于不想被序列化的变量，可以使用transient关键字来修饰 阻止实例中那些用词关键字修饰的变量序列化
  - transient只能修饰变量，修饰的变量在反序列化后变量值就会被置成类型的默认值，**static修饰的变量不会被序列化，因为该变量不属于任何对象**

## 获取class对象的四种方式
- 知道具体类的情况下使用
  ```java
  Class alunbarClass = TargetObject.class;
  ```
- 通过Class.forname()传入全路径获取
  ```java
  Class alunbarClass = Class.forname("cn.TargetObject");
  ```
- 通过对象实例instance.getClass()获取
  ```java
  TargetObject o = new TargetClass();
  Class alunbarClass = o.getClass();
  ```
- 通过类加载器xxxClassLoader.loadClass()传入类路径获取 **通过类加载器获取Class对象不会进行初始化**
  ```java
  ClassLoader.getSystemClassLoader.loadClass("cn.TargetObject")
  ```

## java代理模式
- 代理模式：使用代理对象来代替对真实对象的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能，主要作用是扩展目标对象的功能，比如在目标对象的某个方法执行前后增加一些自定义的操作
- 静态代理：对目标对象的每个方法的增强都是手动完成的，如果接口新增方法，目标对象和代理对象都需要进行修改
  - 实现步骤
    - 定义一个接口及其实现类
    - 创建一个代理类同样实现这个接口
    - 将目标对象注入到代理类，然后在代理类的对应方法调用目标类的对应方法，可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后自定义操作。
- 动态代理
  - jdk动态代理
  - cglib动态代理
  - **JDK 动态代理只能代理实现了接口的类或者直接代理接口**，**而 CGLIB 可以代理未实现任何接口的类**。 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。
- 静态代理和动态代理的比较
  - 灵活性：**动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类**。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！
  - JVM 层面：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。