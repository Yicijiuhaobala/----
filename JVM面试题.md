- 1.JVM是什么
  - java虚拟机，编译器将Java文件编译成平台无关性的java字节码文件.class，对应的JVM对字节码进行解释，翻译成对应平台匹配的机器指令并运行
- 2.JVM内存区域
  - 分为线程私有区和线程共享区， 方法区和堆是共享区，栈是线程私有区
  - 栈
    - 程序计数器
    - Java虚拟机栈
      - java方法执行的线程内存模型，方法执行时，JVM会同步创建一个栈帧，存储局部变量表，操作数栈和动态连接
    - 本地方法栈
  - 堆
    - 存放对象实例，几乎所有的对象实例都在这里分配内存
    - 垃圾回收器管理的内存区域， 根据垃圾回收机制，可以发呢为新生代 老年代  新生代分为Eden区，from survivor空间 to survivor空间
  - 方法区
    - 存储已被虚拟机加载的类信息，常量和静态变量，及时编译器编译后的代码缓存等数据。
    - java虚拟机在加载类时会为静态变量分配一次内存，在方法区中完成静态变量的内存分配1 4。方法区是各个线程共享的内存区域，用于存储已经被虚拟机加载的类信息、常量、静态变量等
  - 运行时常量池：是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。
  - 直接内存：并不是虚拟机运行时数据区的一部分，但也会被频繁使用。它是通过NIO类库中Channel与Buffer来进行操作。
- 3.JDK各版本的内存区域的变化
  - jdk1.6使用永久代实现方法区
  - jdk1.7将字符串常量池 静态变量存放在对上
  - jdk1.8把永久代去除掉，在直接内存中划出一份区域作为元空间，运行时常量池和类常量池都被放在元空间中，元空间来实现方法区
- 4.为什么使用元空间替代永久代来实现方法区
  - 永久代来实现方法区更容易遇到内存溢出的问题，永久代的大小是固定的，而且难以调整
  - 元空间不在虚拟机设置的内存中，而是使用本地内存。这样就可以根据系统可用内存动态调整元空间大小，避免了永久代固定大小带来的限制。另外，元空间也对方法区中存储内容进行了优化和调整，提高了性能和效率
- 5.对象创建的过程
  - 检查new指令，检查类是否被加载，类加载或者初始化检查，对象内存分配，对象内存初始化，设置对象头
- 6.指针碰撞 空闲列表
  - 假设java堆中内存是绝对规整的，所有被使用过的内存存放在一边，没有被使用过的内存存放在另一边，中间放着一个指针作为分界点的指示器。分配内存就是把那个指针想着空闲方向移动一段与对象大小相等的距离
  - java内存不是绝对规整的，各种内存相互交错，那么需要维护一个列表来记录哪些内存块是可用的，在分配内存时找到一块足够大的内存空间分给对象实例，并更新表中记录。
- 7.JVM里new对象，堆会发生抢占吗，jvm怎么保证线程安全
  - 多个为对象分配内存的线程，都会去引用指针进行分配内存，这样会发生抢占。
  - 采用CAS分配重试的方式保证更新操作的原子性
  - 每个线程分配一小块内存也就是本地线程分配缓冲，要分配内存的线程，现在本地缓冲中进行分配，等这个空间不足了，再进行分配新的缓冲区。
- 8.java对象的内存布局
  - 对象头
  - 实例数据
  - 对齐补充
- 9.对象怎么访问定位
- 10.内存溢出和内存泄漏的问题
  - 内存溢出是指申请的内存超过了可用内存，内存不够了
    - Java堆溢出 java堆用于存储对象实例，只要不断创建不可被回收的对象，比如静态对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常
    - 虚拟机栈溢出 虚拟机栈的内存大小是固定的，我们可以跳大栈内存大小，但是不断创造线程，每个进程分配的空间有限，也会导致内存溢出
  - 内存泄漏是指申请的内存空间没有被正确释放，导致内存被白白占用
  - 内存泄漏是会导致内存溢出的。
- 11.内存泄漏可能是哪些原因导致的
  - 静态集合类 静态集合的生命周期与JVM一致，静态集合引用的对象不能被释放
  - 单例模式 单例对象在初始化后会以静态变量的方式在JVM的整个生命周期存在，单例对象持有外部的引用，那么这个外部对象将不能被GC回收
  - 创建的连接不在使用时需要调用close方法
  - hash值发生变化 对象修改后的hash值和存储时的hash值不一样，无法找到存入的对象，将无法删除对象
  - ThreadLocal使用不当没有remove方法进行清除。
- 12.如何判断对象仍然存活
  - 引用技术算法 引用一次计数器值加一，引用失效，值减一，任何时刻计数器为零的对象就不可能再被使用 
  - 可达性分析算法 将一系列GC Roots作为初始的存活对象集合，从该集合出发探索所有能够被该集合引用到的对象，并将该对象引入到该集合中，进行mark
- 13.可以作为GC Roots的对象有哪几种
  - 虚拟机栈中的引用对象
  - 方法区中类静态属性引用的对象
  - 方法区中常量引用的对象
  - 本地方法栈中JNI引用的对象
- 14.对象的几种引用
  - 强引用：程序代码中普遍存在的引用赋值 强引用关系存在，对象就不可能被回收
  - 软引用：有用但非必须的对象，软引用是会进行二次回收的
  - 弱引用：有用但非必须的对象，比软引用更弱，在下一次垃圾回收时一定会被回收，垃圾收集器开始之前，无论内存是否足够，都会被回收掉
  - 虚引用：无法通过虚引用来取得一个对象的实例，唯一目的是为了这个对象在被回收时收到一个系统通知
- 15.finalize()方法
  - finalize()方法的调用时机具有不确定性，从一个对象变得不可到达开始，到finalize()方法被执行，所花费的时间这段时间是任意长的。我们并不能依赖finalize()方法能及时地回收占用的资源。
  - finalize()方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize()的执行;而且执行finalize()方法需要两次标记过程，增加了GC的负担。
  - 对象再生问题：finalize()方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的;但这样做会导致对象状态不确定和逻辑混乱。
  - finalize()方法至多由GC执行一次（用户当然可以手动调用对象的finalize()方法），如果在第一次执行完后又重新复活了，那么下次再被回收时就不会再执行了。
- 16.Java堆的内存分区
  - 根据垃圾回收机制，将java堆分为新生代和老年代两个区域 新生代存放存活时间短的对象，每次回收后存活的对象将会逐步晋升到老年代进行存放。
  - 新生代又分为三个区域 eden  form survivor   to survivor
- 17.垃圾回收算法
  - 标记-清除法
    - 先标记出所有需要被回收的对象
    - 再回收掉所有被标记的对象
    - 会产生大量的内存空间碎片化 产生大量不连续的内存碎片，碎片太多导致在分配大内存的对象时无法找到足够内存空间的连续内存而需要提前进行垃圾回收
  - 标记-复制法
    - 将可用内存分为两部分，每次只使用其中的一部分，当其中一块的内存用完之后，就将存活的对象复制到另一块，再把之前使用过的内存空间一次性清理掉
    - 存在空间浪费的可能，新生代垃圾回收主要采用该算法，新生代存活的对象比较少，每次只需要复制少量的存活对象
  - 标记-整理法
    - 标记的过程与标记清楚法一样，但是会对存活的对象进行整理，将对象网内存空间的一端移动，然后清理掉边界以外的内存。
    - 主要用于老年代，移动存活的对象及其麻烦，这种操作需要stop th world。
- 18.新生代的区域划分
  - 每次分配内存只是用Eden和其中的一块survivor，发生回收时将Eden和survivor中仍然存活的对象一次性复制到另一块survivor空间上，然后清理掉Eden和之前使用过的survivor区域。
- 19.不同的GC代表啥
  - Partial GC 不是完整收集整个java堆的垃圾回收
    - Minor GC/Young GC 只是新生代的垃圾收集
    - Major GC/Old GC 老年代的垃圾收集   CMS收集器独有
    - Mixed GC 混合收集， 整个新生代和部分老年代的垃圾回收  G1收集器独有
  - Full GC 收集整个java堆和方法区的垃圾回收
- 20.Minor GC的触发时机
  - 新创建的对象会优先在Eden去进行分配，如果Eden区没有足够的空间就会触发Minor GC
- 21.Full GC的触发时机
  - Minor GC之前检查老年代 老年代可用的内存空间小于新生代历次Minor GC后升入老年代的对象综合的平均大小。升入老年代的大小超出了老年代当前的可用空间
  - Minor GC之后老年代空间不足：老年代没有足够空间存放需要放入老年代的对象
  - 老年代空间不足，使用率过高
  - 空间分配担保失败：新生代的to区放不下拷贝过来的对象，或者新生代的对象GC年龄达到阈值需要升入老年代，老年代放不下
  - 永久代实现方法区
  - System.gc()等命令触发
- 22.对象什么时候会进入老年代
  - 长期存活的对象，对象年龄已经达到阈值
  - 大对象直接进入老年代 数组或者长字符串
  - 动态对象年龄判断 survivor空间中相同年龄所有对象大小的总和占了survivor一半，年龄大于或等于该年龄的对象就可以直接进入老年代
  - 空间分配担保  经过Minor GC后，新生代的to区放不下拷贝过来的对象
- 23.垃收收集器
  - Serial收集器：串行收集器 stop the world
  - Serial Old收集器
  - ParNew收集器 ：Serial收集器并行版本
  - Parallel Scavenge收集器 关注于吞吐量  吞吐量是CPU用于运行用户代码的时间和总消耗时间的比值
  - CMS收集器：一种以获取最短回收停顿时间为目标的收集器，老年代的收集器，采用标记-清除算法
  - G1收集器：局部收集和基于Region的内存布局形势
- 24.什么是Stop the world
- 25.CMS收集器
  - 初始标记:单线程运行，标记GC Roots能直达的对象
  - 并发标记：无停顿，和用户线程同时进行，遍历整个对象图
  - 重新标记：多线程运行，标记并发标记阶段产生的对象
  - 并发清除：无停顿，和用户线程同时进行，清理对象
- 26.G1收集器
  - 把连续的java堆划分为多个大小相同的独立区域，每个区域都可以根据需要，扮演新生代的Eden,survivor或者老年代空间。避免收集整个堆，而是按照若干个Region进行收集。
  - 初始标记
  - 并发标记
  - 最终标记
  - 筛选回收
- 27.有了CMS为什么还需要G1收集器
  - CMS的优点：并发收集 低停顿
  - 缺点： 
    - 该算法会导致很多的内存碎片
    - 并发清除阶段，用户线程依旧在运作，会产生浮动垃圾，本次垃圾回收不能处理浮动垃圾，只能从、下一次垃圾收集才能处理。浮动垃圾太多会触发新的垃圾回收，导致性能降低
    - 并发能力依赖CPU,并发标记时垃圾收集线程会抢占用户线程，降低用户线程性能。
- 28.垃圾收集器应该如何选择
- 29.对象一定分配在堆中吗，逃逸分析  
  - 在编译期间，JIT会对代码做很多优化，其中一部分优化目的就是为了减少内存堆分配压力。
  - 当一个对象被new之后，他可能被外部所调用，如果是作为参数传递到外部了
- 30.JVM常见的参数配置
- 31.JVM调优
- 32.线上服务CPU占用过高怎么排查
  - 问题分析：一定是某个程序长期占用了CPU资源
  - 首先找出哪个进程占用CPU高 top列出系统各个进程的资源占用情况
  - 然后根据找到对应进行里哪个线程占用CPU高     top -Hp 进程ID 列出对应进程里面的线程占用资源情况
  - 找到对应的线程ID后，再打印出对应线程的堆栈信息
  - 根据线程的对战信息定位到具体业务方法中去，从代码逻辑中找到问题所在
  - 查看线程是否有长时间的watting或者blocked，线程长时间等待锁，根据锁的地址找到持有锁的线程。
- 33.内存飙高怎么排查
- 34.频繁minor GC怎么办
- 35.频繁Full GC怎么办
- 36.如何处理内存泄漏
- 37.如何处理内存溢出
- 38.类的生命周期
  - 类从被加载到虚拟机内存中开始到内存中卸载，整个生命周期会经过七个阶段
  - 加载
  - 验证
  - 准备
  - 解析
  - 初始化
  - 使用
  - 卸载
- 39.类加载的过程
  - 通过一个类的全限定名来获取定义此类的二进制字节流
  - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
  - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
- 40.类加载器
  - 启动类加载器
  - 扩展类加载器
  - 系统类加载器
  - 用户自定义加载器
- 41.双亲委派机制
  - 如果一个类加载器收到了加载类的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都会传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。
- 42.为什么要使用双亲委派机制
  - 保证Java核心类库的安全性和唯一性。通过向上委派机制，可以确保先加载JDK提供的核心类库，避免被用户自定义的同名类覆盖或破坏。
  - 保证用户自定义类库的可扩展性和灵活性。通过向下委派机制，可以确保需要加载的用户自定义类都得到了加载，并且可以根据不同的需求选择不同层次或类型的类加载器