### 基本特征
#### 并发
    并发：宏观上在一段时间内能同时运行多个程序
    并行：同一时刻能够运行多个指令 需要多核处理器，操作系统引入进程线程，实现并行
#### 共享
    资源可以被多个进程共同使用，互斥共享，同时共享、
#### 虚拟
    时分复用技术：让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换
    空分复用技术：将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页不需要全部在物理内存中，当需要用到该页时且不在物理内存中，执行页面置换算法，将该页置换到内存中。
#### 异步
    进程不是一次性执行完毕，以不可知的速度向前推进

#### 宏内核
    将操作系统功能作为整体放到内核
#### 微内核
    将操作系统划分为小的模块，微内核这一个模块在内核态，其他模块在用户态
#### 中断
    外中断：CPU执行指令以外的时间引起， I/O 事件，设备输入/输出，时钟中断 控制台中断
    异常：CPU执行指令内部时间引起，地址越界 算术溢出等
    陷入：用户程序中使用系统调用
#### 进程
    进程：系统资源分配的基本单位 一个程序的执行相当于一个进程
    线程：CPU独立调度的基本单位 一个进程可以有多个线程，共享进程资源
    例子：QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。
    区别：
        拥有资源:线程不拥有资源，线程可以访问隶属于进程的资源
        调度:同一进程中，线程切换不用引起进程切换，但当一个进程的线程切换到另一个进程的线程，会引发进程切换
        系统开销：创建和撤销进程是，会引发特别大的开销，同时进程间的切换也会引发较大的开销。线程切换的开销很小
        通信：线程间可以读取同一进程中的数据进行通信，但进程通信需要借助IPC
#### 进程状态
    reday:就绪状态 等待被调度  就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态
    running:运行状态  运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待被调度
    waiting:阻塞状态 等待资源 缺少相应的资源 从运行状态转为阻塞状态 如I/O事件进行系统调用，完成I/O事件可以转为就绪状态
    created:被创建状态
    terminated:中止状态
#### 进程调度算法
    批处理系统: 系统没有太多的用户操作，调度算法目标是保证吞吐量和周转时间
        FCFS 先来先服务：非抢占式，按照请求顺序进行调度，有利于长作业
        SJF 最短作业优先：非抢占式，按照估计运行时间最短的顺序进行调度 长作业可以一直无法被调度
        SRTN 最短剩余时间优先:最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度
    交互式系统：系统有大量用户进行操作，保证快速进行相应
        时间片轮转：将所有就绪进程拍成队列，每次调度把CPU时间分配给队首进程，当时间片用完执行时钟中断，便停止该进程的执行送完队尾末端，然后再将CPU时间分配给对手进程。时间片太小，进程切换频繁，时间片太大，实时性无法保证
        优先级调度：给每个进程分配优先级，按优先级进行调度
        多级反馈队列：设置多个队列，每个队列的时间片大小不同，进程在第一个队列没有执行完毕被移到下一个队列，每个队列的优先权也不同。只有当上一个队列没有进程在排队，才能调度该队列上的进程。 时间片轮转调度算法和优先级调度算法的结合。
    实时系统：要求请求在一个确定时间内得到响应，分为硬实时和软实时
#### 进程同步
    临界区: 对临界资源进行访问的那段代码称为临界区
    同步: 多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系
    异步: 多个进程在同一时刻只有一个进程能进入临界区、
    信号量: 整形变量，对其执行down up操作
        down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
        up : 对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。
        0 表示临界区已经加锁，1 表示临界区解锁。
#### 管程
    在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程
#### 经典同步问题
    哲学家进餐问题: 
    读者-写者问题: 允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生
#### 进程通信
    进程同步: 控制多个进程按一定顺序执行
    进程通信：进程间传输信息
    进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。
    管道: 只支持半双工通信（单向交替传输）只在兄弟进程和父子进程中使用
    FIFO: 命名管道去除了管道只能在父子进程中使用的限制 常用于客户-服务器应用程序中，传递数据
    消息队列   
        消息队列可以独立于读写进程存在，避免了FIFO中同步管道的打开和关闭时可能产生的困难
        避免了FIFO同步阻塞问题
        读进程可以根据消息类型有选择地接受消息，不像FIFO默认地接受
    信号量: 为多个进程提供共享数据对象的访问
    共享存储: 允许多个进程共享一个给定的存储区，需要使用信号量用来同步对共享存储的访问
    套接字: 用于不同机器间的进程通信

#### 死锁
##### 必要条件
    互斥: 每个资源要么已经分配给了一个进程，要么是可用的
    占有和等待: 已经得到了某个资源的线程可以再请求新的资源
    不可抢占: 已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放
    环路等待: 有两个及其以上的进程组成一个环路，该环路的每一个进程都在等待下一个进程所占用的资源
##### 处理方法
    鸵鸟策略: 忽略掉死锁，解决死锁问题的代价很高，当发生死锁时产生的影响小，采用该方式
    死锁检测与死锁恢复: 不阻止死锁，检测到死锁采取措施进行恢复，单个资源和多个资源
        死锁检测: 通过检测资源分配有向图是否存在环来实现，从一个节点进行深度优先搜索，存在环，检测到死锁发生
        每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。
    死锁恢复: 
        利用抢占式恢复
        利用回滚恢复
        通过杀死进程恢复
    死锁预防: 在程序运行之前预防发生死锁
        破坏互斥条件
        破坏占有和等待条件
        破坏不可抢占条件
        破坏环路等待
    死锁避免: 在程序运行时避免发生死锁
        安全状态: 如果没有发生死锁，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，该状态是安全的
        单个资源的银行家算法
        多个资源的银行家算法

### 内存管理
#### 虚拟内存
    为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存
    操作系统将内存抽象成地址空间，地址空间被分为多个块也就是页。这些页被映射到物理内存，不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到物理内存中不存在的页时，执行页的映射。一个程序不需要全部调入内存就可以完成运行。
#### 分页系统地址映射
    内存管理单元(MMU)管理者地址空间和物理内存的转换，页表存储着程序地址空间(页)和物理内存(页框)的映射表
    一个虚拟地址分成两个部分，一部分存储页面号，一部分存储页面偏移量
#### 页面置换算法
    在程序运行过程中，如果访问的页面不在内存中，则将发生缺页中断将该页调入内存中。如果内存中没有空闲的空间，系统必须从内存中调换出一个页面到磁盘对换区来腾出空间。
    页面置换算法类似缓存淘汰策略，主要目标: 使页面置换频率最低(缺页率最低)

    1.OPT 所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率，理论算法，无法知道一个页面多长时间不再被访问
    2.LRU 将最近最久未使用的页面换出，在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的
    3.NRU 最近未使用 ，随机地从类编号最小的非空类中挑选一个页面将它换出，NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）
    4.FIFO 选择换出的页面是最先进入的页面 会将经常访问的页面换出，导致缺页率升高
    5.第二次机会算法 FIFO算法的改进
    6. 时钟 第二次机会算法需要在链表中移动页面，降低了效率，采用环形链表将页面连接起来，利用指针指向最老的页面

    LRU缓存策略(采用HashMap + 双向链表) LFU 缓存策略 FIFO缓存策略
#### 分段
    虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射，分页是划分成固定大小的
    分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。
#### 段页式
    程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。
#### 分页和分段的比较
    1.对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。
    2.地址空间的维度：分页是一维地址空间，分段是二维的。
    3.大小是否可以改变：页的大小不可变，段的大小可以动态改变。
    4.出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

#### 磁盘调度算法
    读写一个磁盘块的时间的印象因素:
        旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
        寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
        实际的数据传输时间
        其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。
    1.FCFS 先来先服务 按照磁盘请求的顺序进行调度 公平和简单 但是未对寻道做任何优化，使得平均寻道时间可能比较长
    2.SSTF 最短寻道时间优先 优先调度与当前磁头所在磁道距离最近的磁道
    虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象
    3.SCAN 电梯算法 总是按照一个方向进行磁盘调度，直到该方向没有未完成的磁盘请求，然后改变方向。该算法考虑了移动方向，所有的磁盘请求都会被满足，解决了SSTF的饥饿问题


## 线程间的同步方式
- 互斥锁 只有拥有互斥对象的线程才有访问公共资源的权限，互斥的对象只有一个，所以可以保证公共资源不会被多个线程同时访问 java中synchronized和Lock机制都是这种机制
- 读写锁 允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作
- 信号量 允许同一时刻多个线程访问同一资源，但需要控制同一时刻访问此资源的最大线程数量
- 屏障 用于等待多个线程到达某个点再一起继续执行。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。比如 Java 中的 CyclicBarrier 是这种机制
- 事件 wait/notify 通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较
  
## PCB 进程控制块
- 操作系统中用来管理和跟踪线程的数据结构，每个进程都有一个独立的PCB 可以把PCB视为进程的大脑
- 当操作系统创建一个新进程时，会为该进程分配一个唯一的进程 ID，并且为该进程创建一个对应的进程控制块。当进程执行时，PCB 中的信息会不断变化，操作系统会根据这些信息来管理和调度进程。

## 进程间通信的方式
- 管道/匿名管道  用于具有亲缘关系的父子进程间或者兄弟进程之间的通信   只存在于内存中的文件
- 有名管道 匿名管道由于没有名字只能应用于具有亲缘关系的进程间通信  有名管道严格遵循先进先出 以磁盘文件的方式存在，可以实现本机任意两个进程通信
- 信号 通知接收进程某个事件已经发生
- 消息队列  
- 信号量  一个计算器，用于多进程对共享数据的访问，用于进程间同步，解决与同步相关的问题并避免竞争
- 共享内存  得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
- 套接字 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

## 进程的调度算法
- 先到先服务调度算法  
  - 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- 短作业优先的调度算法
  - 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- 时间片轮转调度算法
  - 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
- 多级反馈队列调度算法
  - 短进程优先的调度算法，仅照顾了短进程而忽略了长进程。多级反馈队列调度算法既能使高优先级的作业得到相应又能使短作业迅速完成
- 优先级调度算法
  - 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

## 僵尸进程 孤儿进程
- 在linux系统中，子进程通常都是通过fork()系统调用的，会创建一个新的进程，该进程使原有进程的一个副本，子进程和父进程相互独立，都有各自的PCB，即使父进程结束了，子进程仍然可以继续运行
- 当一个进程调用 exit()系统调用结束自己的生命时，内核会释放该进程的所有资源，包括打开的文件、占用的内存等，但是该进程对应的 PCB 依然存在于系统中。这些信息只有在父进程调用 wait()或 waitpid()系统调用时才会被释放，以便让父进程得到子进程的状态信息。这样的设计可以让父进程在子进程结束时得到子进程的状态信息，并且可以防止出现“僵尸进程”（即子进程结束后 PCB 仍然存在但父进程无法得到状态信息的情况）。
- 僵尸进程：**子进程已经终止，但是其父进程仍在运行，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的 PCB 依然存在于系统中**，但无法被进一步使用。这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 wait()或 waitpid()系统调用来回收子进程。
- 孤儿进程：**一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程**。孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源
  
## 死锁
- 多个线程/进程同时被阻塞，他们中的一个或者多个全部都在等待某个资源被释放，由于它们被无限期阻塞，在无外力的作用下，程序无法正常终止。
- 产生死锁的四个必要条件
  - 互斥
  - 占有并等待
  - 非抢占
  - 循环等待

## 内存管理
- 内存的分配与回收 对进程所需要的内存进行分配与释放， malloc函数：申请内存，  free函数:释放内存
- 地址转换：将程序中的虚拟地址转换为物理地址
- 
