### 物理层
- 解决两台物理机之间通信需求，机器A往机器B发送比特流，机器B能收到比特流，主要作用是传输比特流，将比特流转换为电流强弱传输，到达后在转化为比特流，即常说的数模转换和模数转换
### 数据链路层
- 在传输比特流的过程中会产生差错，数据传输不完整的可能。该层定义了如何格式化数据进行传输，通常提供错误检查和纠正，确保数据传输的准确性，本层将比特流封装成帧，负责物理层面上互联的节点之间的通信传输
#### 基本问题
    1.封装成帧: 将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束
    2.透明传输: 当数据部分出现与首部尾部相同的内容，需要添加转义字符，用户察觉不到转义字符的存在
    3.差错检测: 使用循环冗余检验(CRC)检查比特差错 
#### 信道分类
    1.广播通信: 一对多通信
    2.点对点信道: 一对一通信 不会发生碰撞 使用PPP协议进行控制
#### 信道复用技术
    1.频分复用 所有的主机在相同时间内占用不同频率带宽资源
    2.时分复用 所有的主机在不同时间内占用相同频率带宽资源
    3.统计时分复用
    4.波分复用
    5.码分复用
#### CSMA/CD协议
    多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。
    载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。
    碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。
#### PPP协议
    互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。
    MAC地址: 长度为6字节(48位) 用于唯一标识网络适配器(网卡)
    局域网: 典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限
#### 以太网
    以太网是一种星型拓扑结构局域网。

    早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。

    目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发

    交换机: 具有自学习能力，学习的是交换表的内容，交换表存储着MAC地址到接口的映射

    虚拟局域网: 可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网的成员才回收到数据链路层广播信息，使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。
### 网络层
    网络层向上只提供简单灵活，无连接，尽最大努力交互的数据报服务，该层的数据称为数据报
    使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。
    主要功能是将网络地址转化为对应的物理地址，并决定如何将数据从发送方路由到接收方，寻址和路由。
#### IP地址编址方式
    分类:
    子网划分:
    无分类
#### ARP地址解析协议
    网络层实现主机之间的通信，而链路层实现每段链路之间的通信，在通信过程中，IP数据包的源地址和目的地址始终不变，而MAC地址随着链路的改变而改变。ARP协议实现由IP地址得到MAC地址

    每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。

    如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射 
#### 网际控制报文协议ICMP
    ICMP为了更有效地转发IP数据报和提高数据交付成功的机会，被封装在IP数据报中，分为差错报告报文和询问报文
    Ping 用来测试两台主机之间的连通性 原理：向目的主机发送ICMP echo请求报文，目的主机收到报文之后会发送Echo回答报文。ping根据时间和成功响应的次数估计数据包往返时间和丢包率
    Traceroute 用来跟踪一个分组从源点到终点的路径

#### 虚拟专用网VPN
    由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）
    VPN使用公用的互联网作为本机构各专用网之间的通信载体 专用指机构内的主机只与本机构内的其他主机进行通信
#### 网络地址转换NAT
    专用网内部的主机使用本地的IP地址想和互联网上的主机进行通信时，可以使用NAT将本地IP转换位全球IP。为了更有效的利用全球IP地址，将多个专用网内部的主机共用一个全球IP地址，使用端口号的NAT叫做网络地址与端口转换NAPT
#### 交换机
- 每个电脑的网卡的MAC地址是不同的，数据头部携带的网卡的MAC地址，用MAC地址可以表示不同的电脑，交换机可以识别数据头部的MAC地址，找到电脑连接都得交换机端口，交换机有自学机制，将学习到的设备地址和交换机端口号添加到MAC地址表，根据MAC地址表进行数据转发
#### 路由器
- 交换机的容量和性能有限，局域网内的网络连接可以使用交换机，不同区域的局域网互联使用路由器，路由器有多个端口，分别连接不同的网络区域，不同网络区域的IP地址网络号不同，可以通过识别目的IP地址的网络号，根据路由表进行数据转发
### 传输层
- 数据传输过程中，网络在通信的过程中会中断很多次，此时为了保证传输大量文件时的准确性，需要对发送出去的数据进行切片，分割为一个一个的段落(segment)发送，其中一个段落丢失是否重传，段落是否按序抵达，是传输层需要考虑的问题。传输层解决了主机间的数据传输，数据间的传输可以是不同给的网络，并且传输层解决了传输质量的问题.



### 应用层
#### DNS 域名系统
- DNS解析过程
#### FTP 文件传送协议
#### DHCP 动态主机配置协议
#### TELENT 远程登陆协议
#### 电子邮件协议
    发送协议: SMTP
    读取协议: POP3(只要用户从服务器上读取了邮件，就把该邮件删除，最新版可以不删除邮件) IMAP(保持客户端和服务器上的邮件保持同步，需要手动删除，让用户随时随地去访问服务器上的邮件) 
#### Web页面请求过程
    - DHCH配置主机信息
    - ARP解析MAC地址
    - DNS解析域名
    - HTTP请求页面

### HTTP请求方法
- 1.0 GET POST HEAD 方法 1.1 新增了OPTIONS PUT PATCH DELETE TRACE CONNECT 
- GET与POST的区别
  - get是获取数据，post是修改数据
  - get请求参数是添加再head中的，可以在url中看见，post请求参数是添加在body中的，url中不可以看见
  - get请求会被浏览器缓存下来，留下历史记录而post请求默认不会
  - 浏览器请求的url长度是有限制的，get需要考虑请求参数这个问题，post请求不需要考虑
  - get请求产生一个数据包，就一个请求头，而post请求产生两个数据包，请求头和请求体
  - get请求是幂等的（幂等是指执行相同的操作，结果也是相同的），post请求不是的
- 状态码 
  - 1XX 表示请求被接受，继续处理
  - 2XX 表示请求已经被成功接受，理解和处理
  - 3XX 状态码表示客户端请求的资源发生了变动，需要客户端用新的URL重新发送请求获取资源，也就是重定向
    - 301 永久重定向 之前请求的资源已经不存在了，需要改用新的URL再次访问
    - 302 临时重定向 请求的资源还在，但需要用另一个URL来访问
      - 301 302都会在响应头里面使用字段location 指明后续要跳转的URL 浏览器会自动重定向新的URL
    - 304 不具有跳转的含义，资源未被修改，重定向已经存在的缓存文件，缓冲重定向，用于缓存控制
  - 4XX 客户端发送的报文有无，服务器无法处理
    - 400 请求报文有误
    - 401 未授权认证
    - 403 服务器禁止访问资源
    - 404 请求的资源没有在服务器上找到
  - 5XX 客户端请求报文正确，但是服务器处理时内部发生错误，属于服务器端的错误码
    - 501 客户端请求功能不支持
    - 502 服务器作为网卡或代理时返回的错误码不对
    - 503 服务器正忙，无法响应
    - 504 网关超时，代理服务器不能及时从远程服务器获取应答
- HTTP1.1
  - 长连接:http1.0规定浏览器与服务器只能保持短暂的连接，1.1保证了持久连接，在同一个TCP连接中可以传送多个HTTP请求和响应 需要新的请求头帮助实现 Connection请求头的值为Keep-Alive时，保持连接
  - 管道网络传输： 保证了一个请求发送出去了，不需要等待其发送回来就可以发送第二个请求出去，减少整体的响应时间，但是整体的请求顺序和响应顺序是一致的
  - Host字段 
  - 100状态码： 可以在客户端发送请求body之钱使用request header试探server,看server要不要接受request body ，再决定要不要发送request body
  - 允许发送方将消息分割成若干任意大小的数据块。允许发送发只缓冲消息的一小片段，避免缓存过多造成过载
  - 加入了Cache新特性，缓存对象过期后，重新与源服务器进行重新激活
- HTTP2.0
  - 新的二进制文件 1.1是基于文本的
  - 多路复用也就是连接共享
    - 二进制分帧层 将所有传输的信息分割为更小的消息和帧，并对他们及逆行二进制格式的编码。
  - header压缩 1.x版本header带有大量信息，每次连接需要重复发送，2.0使用encoder来减少需要传送的header大小，通信双方各自cache一份header fileds表，避免重复传输和减小传输的大小
  - 服务器不再是被动等待请求而进行响应，而是可以主动给客户端发送消息，在请求之前把js css文件静态资源主动发送给客户端，减少演示的等待，服务器推送
  - 数据流，2.0数据报不是按顺序发送的，同一连接里的连续的数据包可能属于不同的回应，需要对数据包进行编号，指出它属于的回应。客户端发出的数据流编号为奇数，服务端发出的数据流编号为偶数。还可以指定数据流的优先级。
  - 长连接复用为若干请求排队串行化单线程处理，后面的连接需要前面的请求的返回才能进行执行，一旦某一请求超时，后面请求将会阻塞
  - 多路复用连接时多个请求可同时在一个连接上并行处理，一个请求的极度耗时不会影响其他连接的正常执行
- HTTP3.0
  - 2.0的问题是多个请求复用一个TCP连接。一旦发生丢包现象，就会触发TCP的重传机制。这样在一个TCP连接中的所有HTTP请求必须等待这个丢了的包被重传回来，在重传的这个时候，其他的请求都将被阻塞，因此3.0把TCP协议改成了UDP协议
- HTTP与HTTPS
  - HTTP与HTTPS的区别
    - HTTP是明文传输协议，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输，身份认证的网络协议，比HTTP协议安全
    - HTTPS比HTTP更加安全，对搜索引擎更加友好
    - HTTPS需要用到SSL证书，而HTTP不用
    - HTTPS端口为443 HTTP端口为80
    - HTTPS基于传输层，HTTP基于应用层
    - HTTPS在浏览器显示绿色安全锁，HTTP没有显示
  - HTTPS工作原理
    - HTTPS协议对传输的数据进行加密，而加密过程使用了非对称加密实现
    - 1.客户端发起一个HTTPS请求
    - 2.服务器把实现配置好的公钥证书发送给客户端
    - 3.客户端进行公钥证书的验证，包括是否在有效期内，证书用途是不是匹配客户端请求的站点，上一级证书是否有效，，直到验证到根证书，验证通过则继续，不通过显示警告信息
    - 4.客户端使用伪随机数生成器生成加密所使用的对称密钥，用证书的公钥加密这个对称密钥，发送给服务端
    - 5.服务端利用证书的私钥解密这个消息得到对称密钥，那么客户端和服务端都拥有了这个对称密钥。
    - 6.服务端使用对称密钥加密明文内容，发送给客户端
    - 7.客户端使用对称密钥解密响应的密文，得到明文内容
    - 8.客户端再次发起HTTPS请求，使用对称密钥加密请求的明文内容发送给服务端，服务端使用对称密钥解密密文，得到明文内容。
  - 数字证书
    - 服务器首先把自己的公钥注册到CA 
    - CA利用自己的私钥将服务器的公钥进行数字签名，并颁发数字证书，同时CA的公钥已经事先被置入到浏览器和操作系统里面了
    - 服务端把配置好服务器的公钥的数字签名发送给客户端 客户端拿到服务器的数字证书之后利用CA公钥进行解密确认服务器的数字证书的真实性，获取真实性后就可以获取服务器的公钥，使用它对对称密钥进行加密后发送给服务端
  - 对称密钥和非对称密钥
    - 对称密钥加密试着加密和解密使用同一个密钥的方式，这种方式存在的最大问题是密钥发送问题，如何保证安全地将密钥发给对方
    - 非对称密钥加密是指使用一堆非对称密钥加密，公钥和私钥，发送密文的一方使用对方的公钥进行加密处理，对方收到加密信息后，使用自己的公钥进行解密
    - 我们可以两者结合，利用对称密钥加密信息，对称加密所使用的密钥可以使用非对称加密的方式发送出去。
- TCP
  - 单工： 在任意时刻，数据只能单向发送
  - 半双工：在某个时刻数据可以想一个方向传输，也可以向另一个方向进行反方向传输，而且是交替进行，叫做半双工
  - 全双工：在任何时刻都可以进行双向收发，这就是全双工
  - TCP协议的主要特点
    - 面向连接的传输层协议：双方传输数据时必须先建立一条通道
    - 点对点的
    - 提供可靠的传输服务，传送的数据无差错 不丢失 不重复 按序抵达
    - 提供全双工通信，两端都设有发送缓存和接受缓存
    - 面向字节流：虽然应用程序和TCP交互是一次一个大小不等的数据块，但是TCP把这些数据块看成一连串无结构的字节流
  - TCP的可靠性原理
    - 可靠传输的特点：
      - 传输信道没有差错，保证传输数据正确
      - 不管发送方以多块速度发送数据，接收方总是来得及处理收到的数据
      - 首先采用三次握手进行TCP连接的建立，四次握手来释放TCP连接，从而保证建立的传输信道是可靠的
      - TCP采用连续ARQ协议（回退N；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接收方能够及时处理所接收到的数据，进行流量控制
      - TCP使用满开始，拥塞避免，快重传和快恢复进行拥塞控制，避免网络拥塞
  - TCP报文段 首部+数据
    - 源端口号和目的端口号 各占两个字节
    - seq序号；占4个字节 TCP连接中传送的字节流中的每个字节都按顺序编号
    - ack确认号：占四个字节 期望收到对方下一个报文段的第一个数据字节的序号
    - 数据偏移：头部有可选字段 长度不固定，指出TCP报文段的数据起始处距离报文段的起始处有多远
    - 保留位
    - 控制位：由8个标志位组成，每个标志位表示一个控制功能
    - 窗口： 告知发送端接收端缓存的大小，以此来控制发送端发送数据的速率，达到流量控制
    - 校验和：对整个报文段进行校验  ACK SYN FIN等
    - 紧急指针：当控制位中的URG为1时才有用
    - 其他可选字段
  - TCP粘包和拆包
    - TCP是面向字节流的协议，把上层应用层的数据堪称字节流，发送的不是固定大小的数据包，同时TCP不保证接收方应用程序接受到的数据块和发送发应用程序发送的属数据块有对应的大小关系。
    - TCP不了解上层业务数据的含义，他会根据TCP缓冲区的实际情况进行包的划分，一个完整的数据包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包进行发送，即拆包和粘包
    - 解决策略：
      - 消息定长：每个发送的数据包大小固定
      - 消息末尾增加换行符来表示一条完整的消息，接收方读取时根据换行符来判断是否是一条完整的消息，当数据里包含换行符，此方法不适用
      - 将消息分为消息头和消息尾两部分，消息头指定数据长度，根据消息长度来读取完整的消息，UDP就是这种设计方法
  - 三次握手
    -  第一次握手：客户端将TCP报文标志SYN置为1，随机产生一个序号值seq=J 保存在TCP首部的序列号字段里，知名客户端打算连接的服务器的端口，并发送数据包，客户端处于SYN_SENT状态
    -  第二次握手 服务端收到数据包由SYN为1知晓客户端进行请求连接，服务端将TCP报文段标志SYN ACK都置为1，ack=J+1, 随机产生一个序列号seq=k，并发送给客户端 服务端处于SYN_RCVD状态
    -  第三次握手 客户端接收到服务端，检查ack是否为J+1和ACK是否为1，正确则进行确认并将数据包发送给服务端进行确认。正确则建立连接成功，两者都进入ESTABLISHED状态
    -  小写的ack是头部的确认号，对上一个包的序号进行确认的号
    -  大写的ACK是标志位 用于标志的TCP包是否对上一个包进行了确认。
 -  为什么是三次握手不是四次握手？
    - 防止历史连接初始化了连接
    -  三次握手的过程是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤
    -  两次握手的话，只有连接发起方的起始序列号能被确认，另一方选择的序列号不能得到确认
 -  半连接队列
    -  服务器第一次收到客户端的SYN之后，就会处于SYN_RCVD状态，双反还没有建立起连接，服务器会把这个状态下请求连接放在一个队列里即半连接队列
 -  三次握手过程可以携带数据吗
    -  第一次和第二次都不可以携带数据，第三次可以携带数据 第一次携带数据可能会让服务器更容易被攻击，第三次携带数据是因为第三次对客户端来说已经建立了连接，服务器的接收 发送能力是正常的，可以携带数据。
 -  四次挥手
 -  为什么建立连接时三次握手，断开连接时是四次挥手？
    -  建立连接时服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文，ACK报文是用来应答的，SYN报文时用来同步的，因此建立连接只需要三次握手。
    -  当客户端发送FIN报文时，只是告诉服务端数据已经发送完了，当服务端返回ACK报文段时，表示她已经知道了客户端没有数据要进行发送好了，但是服务端仍然可以发送数据给客户端，服务端这是不会立即关闭连接而是把数据发送完毕。当服务端把数据发送完了，再发送FIN报文段时代表服务端也没有数据要进行发送了，告诉客户端可以关闭此次连接了
 -  为什么TIME_WAIT要等待2MSL
    -  为了保证客户端发送的最后一个ACK报文段能够到达B，该报文段可能丢失，处于LAST_ACK的状态的服务器收不到已发送的ACK + FIN 报文段的确认。B则会超市重传该报文段，A也会重传确认，那么双方就会正常进行CLOSED状态
    -  防止已失效的连接请求报文段出现在本链接中。使本连接持续的时间内所产生的所有报文段都从网络中消失，这样就可以使下一个连接中不会出现这种旧的连接请求报文段
 -  保活计时器
    -  当客户端和服务端已经建立起了TCP连接，但后来的客户端主机突然发生故障，那么服务器不能再接收到客户端发来的数据，此时需要保活计时器进行探测，确保没有客户端的响应，确认客户端发生了故障，关闭连接
 -  
- TCP和UDP的区别
  - TCP是可靠传输，UDP是不可靠传输
  - TCP是面向连接的，UDP无连接
  - TCP传输的数据有序，UDP传输的数据不保证有序
  - TCP不保存数据边界，UDP保留数据边界
  - TCP传输速度相对UDP较慢
  - TCP有流量控制和拥塞控制，UDP没有
  - TCP是重量级协议，UDP是轻量级协议
  - TCP首部较长 20字节 UDP首部只有8字节
- TCP是如何保证可靠传输的
  - 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错误，则丢弃报文段并且不给出响应，这是TCP发送数据段超时后重发数据
  - 对失序数据包重排序：TCP报文段作为IP数据报来传输，IP数据报的抵达会失序，那么TCP报文段也可能会失序，那么TCP会对失序数据报进行重排序，然后交给应用层
  - 丢弃重复数据：丢弃重复数据
  - 应答机制：当TCP收到发自TCP连接另一端的数据时，他将发送一个确认，这个确认不是立即的，会有一定的延迟
  - 超时重发：当TCP发出一个段后，它会启动一个定时器，等待目的端确认收到这个报文段，如果不能即使收到该确认，将重发该报文段
  - 流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP接收端只允许另一端发送接收端缓冲区所能接纳的数据，防止较快主机致使较慢主机的缓冲区溢出，流量控制，使用的是可变大小的滑动窗口协议。
- ARQ协议
  - 自动重传请求协议：停止等待协议中超时重传是只要超过一段时间仍然没有收到确认，就重传前面发送过的分组，认为该分组已经丢失，每发送完一个分组就设置一个超时计时器。
  - 连续ARQ协议可以提高信道利用率，发送方维持一个发送窗口，处于发送窗口内的分组可以连续发送出去，不需要等待对方去无人，接收方采用累计确认，对按序到达的最后一个分组发送确认，表明所有分组正确收到。
- 滑动窗口
  - TCP利用滑动窗口实现流量控制的机制，滑动窗口的大小意味着接收方还有多大的缓冲区可以接收数据，发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口大小为0时一般不能再发送数据。
  - 两种情况除外：一是发送紧急数据，而是发送方可以发送一个1字节的数据报来通知接收方重新声明他希望接受的下一字节以及发送方的滑动窗口大小
  - 流量控制时为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文段中的窗口字段可以用来控制发送方窗口大小，影响发送方的发送速率。
- TCP如何保证有效传输以及拥塞控制原理
  - 拥塞控制：与流量控制不同的时，拥塞控制是一个全局性的过程，流量控制时一个点对点通信的控制。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能变坏，造成拥塞。
  - 为了进行拥塞控制，TCVP发送方要维持一个拥塞窗口的状态遍历。拥塞控制窗口的大小球取决于网络拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。
    - 慢启动阈值： 当主机开始发送数据时，不把大量的数据直接注入到网络中，而是由小到大逐渐增大拥塞窗口。
    - 拥塞避免： 让拥塞窗口缓慢变大，每经过一个往返时间RTT，就把拥塞窗口加1
    - 快速重传+快速恢复：没有FRR,当数据包丢失时，TCP将会使用定时器来要求传输暂停，在暂停的这段时间内，没有新的数据报被发送。当有FRR时，如果接收机接收到一个不按顺序的数据段，他会立即给发送机一个重复确认。如果发送机接收到了三个重复的确认，会确认该数据报丢失并立即重传这个丢失的数据段。当有多个数据信息报在某一段时间内丢失，它不能很有效的工作
    - 



1.计算机网络体系结构
  - OSI七层模型
    - 物理层： 透明地传送比特流传输  尽可能皮笔调具体传输介质和物理设备之间的差异
    - 数据链路层： 帧编码和误差纠正控制  将网络层交下来的IP数据报组装成帧，在两个相邻节点间的链路上传送帧
    - 网络层：路由和寻址 （决定数据在网络的游走路径）  负责分组交换网上的不同主机提供通信服务 选择合适的路由，使源主机运输层所传下来的分组能通过网络层中的路由器找到目的主机
    - 传输层：为两台主机进程之间的通信提供通用的数据传输服务  负责两台终端设备进程之间的通信，提供通用的数据传输服务
    - 会话层：管理（建立、维护、重连）应用程序之间的对话
    - 表示层：数据处理（编解码、加密解密、压缩解压缩）
    - 应用层：为计算机用户提供服务 在TCP/IP四层模型种，应用层主要提供两个终端设备上的应用程序之间信息交换的服务，定义了信息交换的格式，消息会交给下一层传输层来服务  交互的数据单元为报文
  - TCP/IP四层模型
  - 五层模型
  - OSI是一个理论上的网络通信模型，TCP/IP是实际上的网络通信模型，五层结构是为了介绍网络原理而这种的网络通信模型结构
2.数据是如何在各层之间进行传输的
  - 对于发送方而言，从上层到下层进行层层包装，对于接收方，从下层到上层进行层层解开包装
3.从浏览器地址栏输入url到显示主页的过程
  - DNS解析：将域名解析成对应的ip地址  DNS查找过程：浏览器缓存、本地DNS路由缓存、DNS解析服务
  - TCP连接：与服务器通过三次握手，建立TCP连接
  - 向服务器发送HTTP请求
  - 请求数据然后在各层之间进行传输   OPSF协议：IP数据包在路由器之间传输，路由选择使用OPSF协议   ARP协议：路由器在于服务器通信时，需要将IP地址转换为MAC地址，使用ARP协议
  - 服务器接受数据之后进行请求处理，返回HTTP响应
  - 响应的数据在各层之间进行传输
  - 浏览器接收到数据之后进行解析并渲染页面
  - 断开连接：TCP四次挥手，连接结束
4.DNS解析过程
  - 首先会查找浏览器的缓存，是否存在域名对应的IP地址
  - 不存在则将请求发往本地DNS服务器，查看是否存在
  - 不存在，则本地DNS服务器向根域名服务器发送请求服务，根域名服务器返回负责顶级域名服务器的IP地址的列表
  - 本地DNS服务器再向其中一个负责某一顶级域名服务器发送请求，返回负责其中权限域名服务器的IP地址列表
  - 本地DNS服务器向权限域名服务器发送请求，返回对应的IP地址
5.WebSocket与Socket的区别
  - Socket 其实就是等于IP地址+端口+协议  它是一套标准，完成了对TCP/IP的高度封装，屏蔽网络细节，方便开发者进行网络编程  网络编程的标准接口
  - WebSocket 是一个持久化的协议，用来解决HTTP不支持持久化连接的问题
6.常见的端口和对应的服务
  - 21 FTP文件传输协议
  - 22 SSH  安全的网络传输协议
  - 23 Telent 远程登陆服务
  - 80 HTTP 超文本传输协议
  - 53 DNS 域名解析服务
  - 443 HTTPS协议
  - 3306 MYSQL默认端口号
  - 1080 Sockets
7.HTTP报文结构
  - 请求报文
    - 请求行
    - 请求头
    - 请求体
  - 响应报文
    - 响应行
    - 响应头
    - 响应体
  - 常见的头部分为请求头部 响应头部 通用头部 实体头部
    - 请求头部：Accept可接收媒体资源的类型，Accept-Charset可接收的字符集 Host请求的主机名
    - 响应头部：Etag资源的匹配信息 Location客户端重定向的URL
    - 通用头部：Cache-Control控制缓存策略 Connection 管理持久连接
    - 实体头部： Content-length 实体主体的大小 Expires实体主体的过期时间 Last-Modified资源的最后修改时间
8.URL URI的区别
  - URI 统一资源标识符 标识的是Web上每一个可用的资源，如Html文档，图像，视频片段或者程序
  - URL 统一资源定位符 URI的一个子集 主要作用是提供一个资源的路径
  - URI像是一个身份证，可以唯一标识一个人 URL更像是一个地址可以通过URL找到该资源
9.HTTP3
  - 使用UDP作为传输层进行通信
  - 在UDP的基础上QUIC协议保证了HTTP3的安全性，在传输过程就完成了TLS加密握手
  - HTTPS建立一个连接，要花费6次交互，先是建立三次握手，然后是TLS/1.3三次握手，QUIC直接把这个过程合并为了3次
  - QUIC有自己的一套机制可以保证传输的可靠性，当某个流发生丢包时，只会阻塞这个流，其他流不会收到影响。
10.HTTP如何实现长连接？在什么时候会超时？
  - 什么是HTTP长连接
    - HTTP分为长连接和短链接，本质上是TCP的长连接和短连接 TCP连接是一个双向的通道，保持一段时间内不关闭
    - TCP长连接可以复用一个TCP连接，来发起多次的HTTP请求，减少资源消耗，短连接的话还需要请求后续的JS/CSS文件
11.HTTP与HTTPS的区别
  - HTTP是超文本传输协议，信息是明文传输 HTTPS在TCP和HHTP网络层之间加入了SSL/TLS安全协议，使得报文能够加密传输
  - HTTP建立简单，TCP三次握手之后就可以进行HTTP报文传输 HTTP在TCP三次握手之后，还需要进行SSL/TLS的握手过程，才可以进行加密报文传输
  - HTTP端口号80 HTTPS端口号443
  - HTTPS需要向CA申请数字证书，保证服务器的身份是可信的
12.HTTPS解决了哪些问题
  - 窃听风险：通信链路上可以获取通信内容，用户账号被盗
  - 篡改风险：强制植入广告，视觉污染
  - 冒充风险：冒充淘宝网站，用户金钱损失
  - 信息加密：交互信息无法被窃取
  - 校验机制：无法篡改通信内容，被篡改了不能正常显示
  - 身份数字证书：保证服务器的可信
13.HTTPS工作流程
  - 客户端发起HTTPS请求，连接到服务器的443端口
  - 服务端有自己的一套数字证书，证书内容包含公钥，证书颁发机构和失效日期
  - 服务器将自己的数字证书发送给客户端，公钥在证书里，私钥保存在服务器
  - 客户端收到数字证书之后，会验证证书的合法性，如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥进行加密
  - 客户端将公钥加密后的对称密钥发送给服务器
  - 服务器接收到客户端发来的密文之后，用自己保留的私钥对其进行非对称解密，解密之后就可以得到客户端之前生成的对称密钥，然后用客户端密钥对返回数据进行加密，此时传输的数据都是密文了
  - 服务器将加密的密文返回到客户端
  - 客户端收到后，用自己的密钥对其进行解密，得到服务器端返回的数据
14.客户端怎么校验证书的合法性
  - 首先CA签发证书时，会把持有者的公钥、用途、有效时间等信息打成一个包，然后对这些信息进行Hash计算，得到一个Hash值
  - 然后CA会使用自己的私钥将该Hash值进行加密，生成 Certificate Signature 也就是CA对证书做了签名
  - CA将Certificate Signature添加在文件证书上，形成数字证书
  - 客户端进行校验时：
    - 客户端使用同样的Hash算法计算证书的Hash值
    - 浏览器和操作系统继承了CA的公钥，浏览器可以对证书进行解密得到之前的Hash值
    - 然后比较两者，相同则校验为可信赖的证书，反之校验不可信
15.如何理解HTTP协议是无状态的
  - HTTP协议中服务器端是不会存储客户端的任何信息
  - 浏览器第一次发送请求给服务器，服务器进行了响应，当第二次再进行请求发起时，服务器端还是会响应，但是服务器端不知道还是刚才的浏览器发起的请求
16.Session Cookie
  - Cookie是保存在客户端的一小块文本串的数据。客户端向服务器发起请求是，服务端会向客户端发送一个cookie,客户端就把这个cookie保存起来，在客户端下次向同一个服务器发起请求时，cookie被修改发送到服务器。服务器端根据Cookie判断用户的身份和状态
  - Seesion 它是保存在服务器端的，客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，客户端再次访问时只需要从该Session中查找用户的状态
  - 分布式环境下Session怎么处理呢
    - 分布式环境下，客户端请求经过负载均衡，可能会分配到不同的服务器上，可以使用Redis等分布式缓存来存储Session，在多台服务器之间共享
  - 当客户端关闭了Cookie怎么办
    - SessionId可以使用客户端的本地存储，比如浏览器的sessionStorage
    - 在传输过程中，可以直接拼接到URL里，作为请求参数
    - 放到请求投里，把SessionId放到请求的Header里去
17.TCP握手为什么是三次，为什么不能是两次，不能是四次
  - 为了防止服务器端开启一些无用的连接增加服务器开销
    - 确保客户端告诉服务器端发送过来的信息和数据已经被客户端接收，防止服务器端开启很多无效的连接端口，造成资源浪费
  - 防止已经失效的连接请求报文段突然又传送到服务端，因而产生错误
    - client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了
18.三次握手中每一次没收到报文会发生什么情况
  - 第一次握手服务端未收到SYN报文
    - 服务端不会做出任何响应，客户端会重复发送SYN报文，直到发送次数超过最大重传次数限制，返回连接建立失败
  - 第二次握手客户端未收到服务端端响应的ACK报文
    - 客户端继续重传直至次数限制，服务端会阻塞在accept()处，等待客户端发送ACK报文
  - 第三次握手服务端未收到客户端发送的ACK报文
    - 服务器端进行超时重传机制，直至失败，服务器端建立连接失败。但是客户端会认为连接已经建立，开始向服务端发送数据。服务端此时不处于监听状态，接受客户端发来的数据会发送RST报文给客户端，消除客户端单方面建立连接的状态。
19.第三次握手可以携带数据吗
  - 第三次握手是可以携带数据的，此时对于客户端来说，他已经成功建立连接，并且确认服务器端的接收和发送能力都是正常的
  - 第一次握手不能携带数据是出于安全考虑的，允许携带数据那么攻击者可以在SYN报文中携带带量数据，使得服务器花费大量时间和空间去处理这些报文，造成CPU和内存的消耗
20.半连接队列
  - TCP进入三次握手前，服务端会从CLOSED状态变为LISTENED状态，同时在内部创建了两个队列：半连接队列（SYN队列）和全连接队列（ACCEPT队列）
  - 半连接存放的是三次握手未完成的连接，全连接队列存放的是完成三次握手的连接
  - SYN Flood
    - 典型的DDOS攻击，在短时间内，伪造不存的IP地址，向服务器发送大量的SYN报文，当服务器恢复SYN+ACK报文后，不会受到ACK回应报文，那么SYN队列里的连接一直不会出队，久而久之就会沾满服务端的SYN接受队列也就是半连接队列，使得服务器无法为正常用户服务
21.TCP四次挥手
22.TCP挥手为什么需要四次呢
  - 关闭来凝结时，客户端向服务端发送FIN时，仅仅标识客户端不再发送数据了但是还能接受数据
  - 服务端收到客户端的FIN报文时，先回一个ACK应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送FIN报文给客户端来表示同意现在关闭连接
  - 服务端通常需要等待完成数据的发送和处理，所以服务器端的ACK和FIN一般都会分开发送
23.TCP四次挥手过程中，为什么需要等待2MSL，才进入CLOSED状态
  - 为了保证客户端发送的最后一个ACK报文能够到达服务端。这个ACK报文是有可能丢失的，因而处在LAST-ACK状态的服务端就收不到对方已经发送的FIN+ACK报文段的确认。服务端会超时重传这个FIN+ACK报文段，客户端在2MSL时间内收到这个重传的FIN+ACK报文段，客户端会重传确认，重新启动2MSL计时器。最后时间过了都进入CLOSED状态
  - 防止已经失效的连接请求报文段出现在本连接中，等待2MSL，可以使本连接持续的时间内所产生的所有报文段在网络中小时，使得下一个连接中不会出现这种旧的连接的请求报文段
  - MSL是指报文最大生存时间，保温在网络中存在的最长时间，超过这个时间将被丢弃
  - 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又向对方进行响应，一来一回需要等待两倍的时间
24.保活计时器
  - 当客户端主机发生故障，服务器无法再接收来自客户端发来的消息，应当采取应有措施使服务器不要再拜拜等待下去，这个时候需要保活计时器
  - 服务器每次接收到客户端的消息，都会重新设置保活计时器，一次设置为2个小时。两个小时没有收到来自客户端的消息，服务器就发送探测报文段，每隔75秒发送一次，一共发送10次，10次内没有客户端的响应，表示客户端出了故障，断开连接
25.CLOSE-WAIT和TIME-WAIT的状态和意义
  - 服务器端收到客户端关闭连接的请求并确认之后，就会进入CLOSE-WAIT状态，此时服务端还存在一些数据还没有传输完成，不能立即关闭连接。这个状态是为了保证服务器在关闭连接前能传输玩所有待发送的数据
  - TIME-WAIT的意义参考2MSL问题
26.TIME-WAIT状态过多会导致什么问题
  - 内存资源占用
  - 对端口资源的占用，一个TCP连接至少消耗一个本地端口
  尝试使用长连接来减少TCP的连接与断开
27.TCP报文首部的格式
  - 源端口号
  - 目的端口号
  - 序号：一次TCP通信过程中某一个传输方向上的字节流的每个字节的编号
  - 确认号：用作对另一方发送的TCP报文段的响应，其值是收到的TCP报文段的序号值加1
  - 首部长度：表示TCP头部有多少个字节
  - 标志位
  - 窗口大小：TCP流量控制的一个手段，指代接收通告窗口，他告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，控制发送数据
  - 校验和：发送端填充，确认TCP报文段在传输过程中是否损坏，TCP可靠传输的重要保障
  - 紧急指针：紧急指针相对当前序号的偏移，紧急偏移。发送端向接收端发送紧急数据的方法
28.TCP是如何保证可靠性的
  - 连接管理：使用TCP三次握手、四次挥手保证可靠地建立连接和释放连接
  - 校验和：TCP保持首部和数据的校验和，目的是检测数据在传输过程中的任何变化，如果接收端的校验和有差错，TCP将丢弃这个报文段和不确认收到此报文段
  - 序列号/确认应答：TCP给发送的每一个包进行编号，接收方会对收到的包进行应答，发送方就会知道接收方是否收到对应的包。如果没有收到会进行重发，保证数据的完整性
  - 流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理数据，就会提示发送方降低发送数据的速率，防止包丢失。TCP的流量控制协议是可变大小的滑动窗口协议
  - 超时重传：发送出去的数据包接收到确认包之间的时间，如果超过这个时间就会被认为是丢包了，需要进行重传
  - 最大消息长度：建立TCP连接时，双方约定一个最大的长度MSS作为发送的单位，重传也用这个单位。理想情况下该长度的数据刚好不被网络层分块
  - 拥塞控制：如果网络非常拥堵，再发送数据就会加重网络负担，发送的数据段很有可能超过了最大生存时间也没有到达接收方，产生丢包问题。TCP引入慢启动机制，先发送少量数据，先摸清当前的网络拥堵状态，再决定按照多大的速度传送数据
29.TCP的流量控制问题
30.TCP的滑动窗口问题
31.TCP的重传机制
  - 超时重传
  - 快速重传
    - 不以时间驱动，以数据驱动，基于接收端的反馈信息来引发重传 三次重复的ACK就会触发重传机制  解决了超时的问题，但是面临着另外一个问题，时重传唯一失败的那一个，还是重传失败及其之后的所有报文
  - 带选择确认的重传 SACK
    - 在快速重传的基础上，接收方返回最近收到报文段的序列号范围，发送方就知道接收方哪些数据包是没有收到的，就知道重传哪些数据了
  - 重复SACK
    - SACK的基础拓展，用来告诉发送方，有哪些数据包自己重复接受了，帮助发送方判断是否发生了包失序，ACK丢失、包重复或者伪重传
32.TCP粘包与拆包
  - TCP是面向流的，没有界限的一串数据，TCP底层并不了解上层业务数据的具体含义，他会根据TCP缓冲区的实际情况进行包的划分，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小包封装成大的数据包进行发送。
  - 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包
  - 接收端的应用没有及时读取缓冲区中的数据，发生粘包
  - 要发送的数据大于TCP发送缓冲区的大小
  - 待发送的数据大于MSS，TCP报文长度-TCP头部长度>MSS
  - 解决：
    - 发送端将每个数据包封装成固定长度
    - 在数据末尾增加特殊字符进行分割
    - 将数据分为两部分，头部和内容体，头部结构大小固定，有一个字段声明内容体的大小
33.UDP
  - UDP协议是无连接方式的协议，它的效率高，速度快，占用资源少，对服务器的压力比较小。但其传输机制为不可靠传输，必须依靠辅助的算法来完成给传输控制
  - 为什么不可靠：
    - 不保证消息交付：不确认，不重传，无超时
    - 不保证交付顺序：不设置包序号。补充拍，不会发生队首阻塞
    - 不跟踪连接状态：不必建立连接或重启状态机
    - 不进行拥塞控制：不设置客户端或者网络反馈机制
34.DNS为什么同时使用UDP和TCP
35.对称加密和非对称加密的区别
  - 对称加密：加密和界面使用同一密钥，有点事运算速度较快，缺点是如何安全地将密钥传输给另一方，DES AES
  - 非对称加密：加密和解密使用不同的密钥（公钥和密钥），公钥和密钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。RSA



36.内网穿透
https://mp.weixin.qq.com/s/z22Rvdv42SJR-MLH71wwew
  - 想把内网中服务开放给互联网上的人使用，有两种解决方式：
    - 将该服务部署到公网服务器上：但是该方法一旦修改源代码需要重新部署，公网服务器的硬件配置不一定能满足服务启动的所有要求
    - 内网穿透，将当前的内网 IP 和一个可访问的公网 IP 建立联系，使得别人可以通过公网 IP 访问你的本地主机
    - 一般情况下，私有网络中的计算机无法被公网访问，因为它们的 IP 地址是内网 IP，不能直接被公网访问。内网穿透技术通过将公网上的请求转发到内网中的计算机上，从而实现了内网计算机与外网之间的数据通信
    - 实现方法：
      - 端口映射
        - 端口映射是一种将公网上的 IP 地址和端口映射到局域网内一台计算机的指定端口上的技术。实现端口映射需要在路由器上进行配置，将路由器的公网 IP 地址和端口与内网中的计算机的 IP 地址和端口相映射。当公网用户请求这个 IP 地址和端口时，路由器会将请求转发到内网计算机的指定端口上，从而实现内网穿透。
      - 反向代理
        - 将公网上的访问请求转发到局域网内一台计算机的指定端口上的技术。实现反向代理需要在公网服务器上部署一个代理服务器，在代理服务器上配置反向代理规则，将公网请求转发到内网服务器上的指定端口。从而实现内网穿透
      - VPN
      - NAT穿透 

37.redis消息队列
https://www.zhihu.com/question/20795043/answer/1931265868
  - List 
    - 不支持重复消费，消费者拉取消息后，这条消息就被删除了，无法被其他消费者再次消费，即不支持多个消费者消费同一批数据，
    - 消息低俗hi：消费者拉去到消息后，如果服务宕机了，数据就会丢失掉
  - 发布订阅模式
    - 支持多组生产者消费者处理消息
    - 消费者下线，数据会丢失
    - 不支持数据持久化，Redis宕机，数据会丢失
    - 消息堆积，缓冲区溢出，消费者会被强制踢下线，数据也会丢失
  - Stream数据结构
  - Redis作为队列中间件是存在消息丢失的可能
    - AOF持久化配置为每秒写盘，但这个写盘是异步的，Redis宕机时会存在数据丢失的
    - 主从复制也是异步的，主从切换也存在丢失数据的可能
  - Redis面对消息积压，内存资源是紧张的