# 内部划分
 - 类加载器(Class Loader)
   - 类加载器是 Java 虚拟机的一个子系统，用于加载类文件。每当我们运行一个 Java 程序，它都会由类加载器首先加载
 - 运行时数据区(Runtime Data Areas)
   - PC寄存器(程序计数器)
   - JVM栈
   - 本地方法栈
   - 堆
   - 方法区
   - 运行时常量池
 - 字节码执行引擎(Excution Engine)
### JVM运行java代码
    在编译阶段，Java 会将 Java 源代码文件编译为字节码文件。在这个阶段，编译器会进行一些检查工作，比如说，某个关键字是不是写错了，语法上是不是符合预期了，不能有很明显的错误
    JVM 就是靠解析这些 opcode 和操作数来完成程序的执行的。当我们使用 Java 命令运行 .class 文件的时候，实际上就相当于启动了一个 JVM 进程。

    然后 JVM 会翻译这些字节码，它有两种执行方式。常见的就是解释执行，将 opcode + 操作数翻译成机器代码；另外一种执行方式就是 JIT，也就是我们常说的即时编译，它会在一定条件下将字节码编译成机器码之后再执行。
### 类加载过程
    - 加载:将字节码从不同的数据源（可能是 class 文件、也可能是 jar 包，甚至网络）转化为二进制字节流(静态数据存储结构)加载到内存中(运行时数据结构)，并在内存生成一个代表该类的 java.lang.Class 对象
    - 验证:对二进制字节流进行校验，只有符合 JVM 字节码规范的才能被 JVM 正确执行
    - 准备:对类变量（也称为静态变量，static 关键字修饰的）分配内存并初始化（对应数据类型的默认初始值，如 0、0L、null、false 等）
    - 解析:将常量池中的符号引用转化为直接引用 就是得到类或者字段、方法在内存中的指针或者偏移量 
      - 符号引用: 一组符号来描述目标，可以是任何字面量
      - 直接指向目标的指针、相对偏移或一个间接定位到目标的句柄
    - 初始化:类变量将被赋值为代码期望赋的值。换句话说，初始化阶段是执行类构造器方法的过程。带锁线程安全
      - jvm执行new指令会初始化类，即当程序创建一个类的实例对象
      - jvm执行getstatic会初始化类，程序访问类的静态变量(静态常量被加载到了运行时常量池)
      - jvm执行putstatic会初始化类，程序给类的静态变量赋值
      - jvm执行invokestati会初始化类，程序调用类的静态方法
    - 卸载:即该类的对象被GC，卸载类
      - 该类的所有实例对象都被GC，堆中不存在该类的实例对象
      - 该类没有在其他地方被引用
      - 该类的类加载器已经被GC 
### 类加载器
  - 一个非数组类的加载阶段(加载阶段获取类的二进制字节流的动作)是可控性最强的阶段，我们可以自定义类加载器区控制字节流的获取方式(重写一个类加载器的loadClass()方法)。数组类型不通过类加载器创建，由java虚拟机直接创建
  - 所有的类都有类加载器加载，将.class文件加载到内存中去
  - BootstrapClassLoader(启动类加载器)
  - ExtensionClassLoader(扩展类加载器)
  - AppClassLoader(应用程序类加载器)
### 双亲委派模型
  - 每个类都有对应的类加载器，系统中的ClassLoader在协同工作时会默认使用双亲委派模型。也就是在类加载的时候，系统首先会判断当前类是否被加载过，如果已经被加载过会直接返回，否则才尝试加载。
  - 在加载的时候，首先会把请求委派给父类加载器的loadClass()处理，所有的请求最终应该传送到顶层的启动类加载器中，当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器作为父类加载器
  - 自底向上检查类是否被加载，自顶向下尝试加载类，类加载器之间的关系不是通过继承实现的，而是通过“优先级”实现的，不是所谓的继承关系。
  - 好处:
    - 保证java运行的稳定，避免类的重复加载(JVM区分不同的类的方式不仅仅根据类名，相同的类文件被不用的类加载器加载产生不同的类，保证了java的核心API不被篡改)
  - 自定义加载类: 除了启动类加载器不由java实现且继承ClassLoader类，其他类加载器则需要继承ClassLoader，包括自定义类加载器。如果不想打破双亲委派模型，重写ClassLoader类中的findClass()方法，无法被父类加载器加载的类最终会通过这个方法被加载，如果想打破双亲委派模型，则重写ClassLoader的loadClass()方法

### Java内存区域
#### 程序计数器
  - 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
  - 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
  - 生命周期随着线程创建而创建，随着线程结束而死亡
#### Java虚拟机栈 8种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存的
  - 与程序计数器一样，线程私有，生命周期随着线程创建而创建，随着线程结束而死亡
  - 除了一些方法Native方法是通过本地方法栈实现，其他所有的java方法调用都是通过栈实现的
  - 方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出
  - 栈由一个个栈帧组成，每个栈帧拥有 局部变量表 操作数栈 动态链接 方法返回地址
    - **局部变量表**主要存放了编译期可知的各种数据类型（基本的数据类型）、对象引用（不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）
    - **操作数栈** 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果，产生的临时变量也会存储在这儿
    - **动态链接** 主要服务于一个方法需要调用其他方法的场景。 Class文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法时，需要将常量池中指向方法的符号引用转换为内存地址中的直接引用。 其作用就是将符号引用转换为调用方法的直接引用。 
  - StackOverFlowError： 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。
  - OutOfMemoryError： 如果栈的内存大小可以动态扩展，如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。
#### 本地方法栈
  虚拟机栈为虚拟机执行java方法服务，也就是字节码，本地方法栈为虚拟机使用Native方法服务，基本同java虚拟机栈
#### 堆
  - 内存中最大的一块，是线程共享的，此内存区域的唯一目的就是存放对象实例，**几乎所有的对象实例以及数组都在堆里分配内存**
  - **jdk1.7默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用，那么对象直接在栈上分配内存**
  - java堆是垃圾收集器管理的主要区域，GC堆。由于收集器基本都是采用分代垃圾收集算法，java堆还可以分为新生代 老年代 再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存
  - jdk1.8之前 堆内存被分为 新生代内存 老年代内存 永久代 **jdk1.8之后永久代被替换为元空间，同时元空间使用的是直接内存**
  - 大部分情况下，对象首先都会在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入S0或者S1，并且对象的年龄还会加1(Eden区->Survivor区后对象的初始年龄变为1)，当他的年龄增加到一定程度(默认为15)，就会晋升到老年代。
  - **Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累计，当累计的某个年龄大小超过survivor区的一半时，去这个年龄和老年代年龄阈值中小的一个值作为新的晋升阈值**
  - java.lang.OutOfMemoryError: GC Overhead Limit Exceeded ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
  - java.lang.OutOfMemoryError: Java heap space :假如在创建对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过-Xmx参数配置，若没有特别配置，将会使用默认值)
#### 方法区
  - 方法区属于JVM运行时数据区域的一块逻辑区域，是各个线程共享的内存区域
  - 当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据
  - 方法区是一个抽象概念/规范，类似于Java中的接口，而永久代和元空间是方法区的具体实现，永久代已经被元空间所替代
  - 永久代有一个JVM本身设置的固定大小上限，无法进行调整，元空间使用的是直接内存，受本机内存的限制
  - 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了
#### 运行时常量池
  方法区的一部分 受到方法区内存的限制，用于存放编译器生成的各种字面量和符号引用的常量池表 
  运行时常量池的功能类似传统变成语言的符号表，尽管它包含了比典型符号表更广泛的数据
#### 字符串常量池
  - **为了提升性能和减少内存消耗，针对字符串专门开辟的一块区域，主要目的是为了避免字符串的重复创建**  
  - 字符串常量池保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象 jdk1.7之前 字符串常量池存放在永久代中，jdk1.7中字符串常量池和静态变量从永久代移动到了java堆中
  - **永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存**
  - 运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的
  - 线程私有:
    - 程序计数器
    - 虚拟机栈
    - 本地方法栈
  - 线程共享:
    - 堆
    - 方法区
    - 本地方法栈
### HotSpot虚拟机
- 对象的创建
  - 类加载检查 ： 虚拟机遇到一条new指令，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载锅、解析喝初始化过。如果没有则执行相应的类加载过程
  - 分配内存： 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。 分配内存的方式有指针碰撞和空闲列表两种 java堆是否规整取决于垃圾收集器是否带有压缩整理功能
    - **指针碰撞 ：适用于堆内存规整的情况下，用过的内存放在一遍，没有用过的内存放在另一边，中间有一个分解指针，只需要向着没用过的内存方向将该指针移动对象内存大小的位置**
    - **空闲列表： 适用于堆内存不规整的情况下， 虚拟机会维护一个列表，该列表记录哪些内存块是可用的，再分配的时候找一块儿足够打的内存块划分给对象实例，然后进行列表记录更新。**
  - 初始化零值： 将分配的内存空间都初始化为零值，保证对象的实例字段在java代码中可以不赋初始值就可以使用
  - 初始化零值之后，虚拟机要对对象进行必要的对象头设置，例如这个对象是哪个类的实例、对象的哈希码、对象的GC分代年龄，这些信息存放在对象头中
  - 执行init方法： 把对象按照程序员的意愿进行初始化。
- 对象的内存布局
  - **对象头**
    - 存储对象自身的运行时数据 （哈希码、GC分代年龄、锁状态标志等等）
    - 类型指针 对象执行它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例
  - **实例数据  对象真正存储的有效信息，在程序中所定义的各种类型的字段内容**
  - 对齐补充  起占位作用
- 对象的访问定位
  - 使用句柄  java堆中划分出一块内存来作为句柄池 存储着对象的句柄地址， 句柄中包含了对象实例数据与对象数据各自的具体地址信息
  - 直接指针  直接存储对象的地址
### 堆空间的基本结构
  - java自动内存管理主要是针对对象内存的回收和对象内存的分配。针对堆内存中的对象的分配和回收
#### 内存分配和回收原则
  - 对象优先在Eden区分配: 对象在Eden区分配，当Eden区没有足够的空间进行分配时，虚拟机将发起以此Minor GC。当GC期间虚拟机发现之前分配的对象无法分配到Survivor空间时，只能通过分配担保机制把新生代的对象提前转移到老年代中去，当老年代足以存放之前分配的对象时，不会发生Full GC。执行Minor GC后，分配的对象如果能够存在Eden区的话，还是会在Eden去分配内存
  - 大对象直接进入老年代: 大对象就是需要大量连续内存空间的对象(数组，字符串)，避免为大对象分配内存时由于分配担保机制带来的复制而降低效率
  - 长期存活的对象将进入老年代: 虚拟机给每个对象一个对象年龄计数器。大部分情况下，对象首先会被分配在Eden区域，如果对象在Eden出生并在经过以此Minor GC之后仍然能够存活，并能被Survivor空间，将对象年龄设置为1，对象在Survivor中每经过一次Minor GC 年龄就会增加一岁，当年龄增加到年龄阈值时会被晋升到老年代。Hotspot的默认年龄阈值为15
  - GC分类:
    - 部分收集(Partial GC)
      - 新生代收集: 只对新生代进行垃圾收集
      - 老年代收集: 只对老年代进行垃圾收集
      - 混合收集: 对整个新生代和部分老年代进行垃圾收集
    - 整堆收集(Full GC): 收集整个java堆和方法区
  - 空间分配担保: 确保在Minor GC之前老年代本身还有容纳新生代所有对象的剩余空间
##### 死亡对象判断方法
  堆中几乎存放着所有的对象实例，垃圾回收之前要判断哪些对象已经死亡
  - 引用计数法: 简单高效，但是不能解决对象之间相互循环引用的问题
  - 可达性分析: 将GC Roots对象作为起点，从这些节点开始向下搜索，节点走过的路径称为引用链，一个对象到GC Roots没有任何引用链相连的话，证明该对象不可用，需要被回收
    - **可以作为GC Roots的对象**
      - 虚拟机栈(栈帧中的本地变量表)中引用的对象
      - 本地方法栈(Native 方法)中引用的对象
      - 方法区中类静态属性引用的对象
      - 方法区中常量引用的对象
      - 所有被同步锁持有的对象
  - **引用类型  如果reference类型的数据存储的数值代表是另一块内存的起始地址，就称这块内存代表一个引用**
    - 强引用: 垃圾回收器不会回收该对象，宁愿抛出错误
    - 软引用: 可有可无 内存空间足够不会回收 内存不足进行对象内存的回收 用得较多 加速JVM堆垃圾内存的回收速度，加速维护系统的运行安全，防止内存溢出等问题的产生
    - 弱引用: 可有可无，相比于软引用具有更短暂的生命周期，不管内存空间足够与否，都会进行内存回收 弱引用和软引用都可以配合引用队列联合使用，当被垃圾回收之后，会把弱引用或者软引用加入到与之关联的引用队列中
    - 虚引用: 形同虚设，一个对象只有虚引用，如同没有任何引用一样，在任何时候都能被回收，用于跟踪对象被垃圾回收的活动，
  - 如何判断一个常量是废弃常量？
    - 没有任何String对象引用该字符串常量时，它就是废弃常量
  - 如果判断一个类时无用类？需要同时满足以下三大条件
    - 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
    - 加载该类的 ClassLoader 已经被回收。
    - 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
##### 垃圾收集算法
  - 标记清除法: 首先标记出所有不需要回收的对象，在标记完成之后统一回收掉所有没有被标记的对象，最基本的收集算法。 
    - 缺陷：效率问题，空间问题(标记清除后会产生大量不连续的碎片)
  - 标记复制法: 将内存分为大小相同的两块，每次使用其中的一块，当这一块的内存使用完之后，就将还存活的对象复制到另一块区，再把该空间进行清理，每次内存回收都是对其中的一半进行回收
  - 标记整理法: 标记过程与标记清除一样，但后续时让所有存活的对象向一段移动，然后直接清理掉端边界以外可以回收的内存
  - 分代收集法: 根据对象生存周期的不同将内存分为几块，分为新生代和老年代，根据各个年龄代选择不同的垃圾收集算法
    - 在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。
    - 而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集
##### 垃圾收集器
  - Serial收集器: 单线程，只有一条垃圾线程区完成垃圾收集工作，它在进行垃圾收集工作时必须暂停其他所有的工作线程(Stop the world)，直到它收集结束，由于时单线程，简单高效，没有线程交互的开销
  - ParNew收集器: 多线程版本的Serial收集器 
    - 并行: 多条垃圾收集线程并行工作，此时用户线程仍然处于等待状态
    - 并发: 垃圾收集线程和用户线程同时进行，用户线程继续运行，垃圾收集线程运行在另一个CPU
  - Parallel Scavenge收集器 ，关注点在于吞吐量，高效的利用CPU，吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值
  - Serial Old 收集器: Serial收集器的老年代版本
  - Parallel Old 收集器: Parallel Scavenge收集器的老年代版本
  - CMS(Concurrent Mark Sweep)收集器:以获取最短回收停顿时间为目标的收集器，第一次实现了让垃圾收集线程和用户线程基本上同时工作，是一种标记清除算法，并发收集，低停顿
    - 初始标记:
    - 并发标记:
    - 重新标记:
    - 并发清除:
    - 缺点:
      - 对CPU资源敏感
      - 无法处理浮动垃圾
      - 使用的标记清除算法或导致收集结束后产生大量空间碎片产生
  - G1(Garbage-first)收集器:面向服务器的垃圾回收器，配备多颗处理器以及大容量内存的机器，获取最短回收停顿时间和高吞吐量性能
    - 初始标记
    - 并发标记
    - 最终标记
    - 筛选回收
### JVM调优
 - 调整最大堆内存和最小堆内存
 - 调整新生代和老年代的比值
 - 调整Survivor区和Eden区的比值
 - 设置年轻代和老年代的大小
 - 永久区的设置 元空间
 - JVM栈参数调优
   - 调整每个线程栈空间的大小
   - 设置线程栈的大小
   - 设置内存页的大小
   - 设置原始类型的快速优化
   - 
